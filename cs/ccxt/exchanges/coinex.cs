namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class coinex : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "coinex" },
            { "name", "CoinEx" },
            { "version", "v1" },
            { "countries", new List<object>() {"CN"} },
            { "rateLimit", 2.5 },
            { "pro", true },
            { "certified", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", true },
                { "borrowCrossMargin", false },
                { "borrowIsolatedMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "createDepositAddress", true },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", true },
                { "createReduceOnlyOrder", true },
                { "createStopLossOrder", true },
                { "createTakeProfitOrder", true },
                { "createTriggerOrder", true },
                { "editOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowInterest", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchClosedOrders", true },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddressByNetwork", false },
                { "fetchDepositAddresses", false },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", true },
                { "fetchIsolatedBorrowRates", true },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", true },
                { "fetchMarketLeverageTiers", "emulated" },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchPosition", true },
                { "fetchPositions", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", true },
                { "fetchTransfer", false },
                { "fetchTransfers", true },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", true },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", true },
                { "setLeverage", true },
                { "setMarginMode", true },
                { "setPositionMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1min" },
                { "3m", "3min" },
                { "5m", "5min" },
                { "15m", "15min" },
                { "30m", "30min" },
                { "1h", "1hour" },
                { "2h", "2hour" },
                { "4h", "4hour" },
                { "6h", "6hour" },
                { "12h", "12hour" },
                { "1d", "1day" },
                { "3d", "3day" },
                { "1w", "1week" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/51840849/87182089-1e05fa00-c2ec-11ea-8da9-cc73b45abbbc.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.coinex.com" },
                    { "private", "https://api.coinex.com" },
                    { "perpetualPublic", "https://api.coinex.com/perpetual" },
                    { "perpetualPrivate", "https://api.coinex.com/perpetual" },
                } },
                { "www", "https://www.coinex.com" },
                { "doc", "https://github.com/coinexcom/coinex_exchange_api/wiki" },
                { "fees", "https://www.coinex.com/fees" },
                { "referral", "https://www.coinex.com/register?refer_code=yw5fz" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "amm/market", 1 },
                        { "common/currency/rate", 1 },
                        { "common/asset/config", 1 },
                        { "common/maintain/info", 1 },
                        { "common/temp-maintain/info", 1 },
                        { "margin/market", 1 },
                        { "market/info", 1 },
                        { "market/list", 1 },
                        { "market/ticker", 1 },
                        { "market/ticker/all", 1 },
                        { "market/depth", 1 },
                        { "market/deals", 1 },
                        { "market/kline", 1 },
                        { "market/detail", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "account/amm/balance", 40 },
                        { "account/investment/balance", 40 },
                        { "account/balance/history", 40 },
                        { "account/market/fee", 40 },
                        { "balance/coin/deposit", 40 },
                        { "balance/coin/withdraw", 40 },
                        { "balance/info", 40 },
                        { "balance/deposit/address/{coin_type}", 40 },
                        { "contract/transfer/history", 40 },
                        { "credit/info", 40 },
                        { "credit/balance", 40 },
                        { "investment/transfer/history", 40 },
                        { "margin/account", 1 },
                        { "margin/config", 1 },
                        { "margin/loan/history", 40 },
                        { "margin/transfer/history", 40 },
                        { "order/deals", 40 },
                        { "order/finished", 40 },
                        { "order/pending", 8 },
                        { "order/status", 8 },
                        { "order/status/batch", 8 },
                        { "order/user/deals", 40 },
                        { "order/stop/finished", 40 },
                        { "order/stop/pending", 8 },
                        { "order/user/trade/fee", 1 },
                        { "order/market/trade/info", 1 },
                        { "sub_account/balance", 1 },
                        { "sub_account/transfer/history", 40 },
                        { "sub_account/auth/api", 40 },
                        { "sub_account/auth/api/{user_auth_id}", 40 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "balance/coin/withdraw", 40 },
                        { "contract/balance/transfer", 40 },
                        { "margin/flat", 40 },
                        { "margin/loan", 40 },
                        { "margin/transfer", 40 },
                        { "order/limit/batch", 40 },
                        { "order/ioc", 13.334 },
                        { "order/limit", 13.334 },
                        { "order/market", 13.334 },
                        { "order/modify", 13.334 },
                        { "order/stop/limit", 13.334 },
                        { "order/stop/market", 13.334 },
                        { "order/stop/modify", 13.334 },
                        { "sub_account/transfer", 40 },
                        { "sub_account/register", 1 },
                        { "sub_account/unfrozen", 40 },
                        { "sub_account/frozen", 40 },
                        { "sub_account/auth/api", 40 },
                    } },
                    { "put", new Dictionary<string, object>() {
                        { "balance/deposit/address/{coin_type}", 40 },
                        { "sub_account/unfrozen", 40 },
                        { "sub_account/frozen", 40 },
                        { "sub_account/auth/api/{user_auth_id}", 40 },
                        { "v1/account/settings", 40 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "balance/coin/withdraw", 40 },
                        { "order/pending/batch", 40 },
                        { "order/pending", 13.334 },
                        { "order/stop/pending", 40 },
                        { "order/stop/pending/{id}", 13.334 },
                        { "order/pending/by_client_id", 40 },
                        { "order/stop/pending/by_client_id", 40 },
                        { "sub_account/auth/api/{user_auth_id}", 40 },
                        { "sub_account/authorize/{id}", 40 },
                    } },
                } },
                { "perpetualPublic", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "ping", 1 },
                        { "time", 1 },
                        { "market/list", 1 },
                        { "market/limit_config", 1 },
                        { "market/ticker", 1 },
                        { "market/ticker/all", 1 },
                        { "market/depth", 1 },
                        { "market/deals", 1 },
                        { "market/funding_history", 1 },
                        { "market/kline", 1 },
                    } },
                } },
                { "perpetualPrivate", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "market/user_deals", 1 },
                        { "asset/query", 40 },
                        { "order/pending", 8 },
                        { "order/finished", 40 },
                        { "order/stop_finished", 40 },
                        { "order/stop_pending", 8 },
                        { "order/status", 8 },
                        { "order/stop_status", 8 },
                        { "position/finished", 40 },
                        { "position/pending", 40 },
                        { "position/funding", 40 },
                        { "position/adl_history", 40 },
                        { "market/preference", 40 },
                        { "position/margin_history", 40 },
                        { "position/settle_history", 40 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "market/adjust_leverage", 1 },
                        { "market/position_expect", 1 },
                        { "order/put_limit", 20 },
                        { "order/put_market", 20 },
                        { "order/put_stop_limit", 20 },
                        { "order/put_stop_market", 20 },
                        { "order/modify", 20 },
                        { "order/modify_stop", 20 },
                        { "order/cancel", 20 },
                        { "order/cancel_all", 40 },
                        { "order/cancel_batch", 40 },
                        { "order/cancel_stop", 20 },
                        { "order/cancel_stop_all", 40 },
                        { "order/close_limit", 20 },
                        { "order/close_market", 20 },
                        { "position/adjust_margin", 20 },
                        { "position/stop_loss", 20 },
                        { "position/take_profit", 20 },
                        { "position/market_close", 20 },
                        { "order/cancel/by_client_id", 20 },
                        { "order/cancel_stop/by_client_id", 20 },
                        { "market/preference", 20 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "maker", 0.001 },
                    { "taker", 0.001 },
                } },
                { "funding", new Dictionary<string, object>() {
                    { "withdraw", new Dictionary<string, object>() {
                        { "BCH", 0 },
                        { "BTC", 0.001 },
                        { "LTC", 0.001 },
                        { "ETH", 0.001 },
                        { "ZEC", 0.0001 },
                        { "DASH", 0.0001 },
                    } },
                } },
            } },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", 0.001 },
                    { "max", null },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "brokerId", "x-167673045" },
                { "createMarketBuyOrderRequiresPrice", true },
                { "defaultType", "spot" },
                { "defaultSubType", "linear" },
                { "fetchDepositAddress", new Dictionary<string, object>() {
                    { "fillResponseFromRequest", true },
                } },
                { "accountsById", new Dictionary<string, object>() {
                    { "spot", "0" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "BEP20", "BSC" },
                    { "TRX", "TRC20" },
                    { "ETH", "ERC20" },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "ACM", "Actinium" },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "23", typeof(PermissionDenied) },
                    { "24", typeof(AuthenticationError) },
                    { "25", typeof(AuthenticationError) },
                    { "34", typeof(AuthenticationError) },
                    { "35", typeof(ExchangeNotAvailable) },
                    { "36", typeof(RequestTimeout) },
                    { "213", typeof(RateLimitExceeded) },
                    { "107", typeof(InsufficientFunds) },
                    { "600", typeof(OrderNotFound) },
                    { "601", typeof(InvalidOrder) },
                    { "602", typeof(InvalidOrder) },
                    { "606", typeof(InvalidOrder) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "ip not allow visit", typeof(PermissionDenied) },
                } },
            } },
        });
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetCommonAssetConfig(parameters);
        //     {
        //         "code": 0,
        //         "data": {
        //             "USDT-ERC20": {
        //                  "asset": "USDT",
        //                  "chain": "ERC20",
        //                  "withdrawal_precision": 6,
        //                  "can_deposit": true,
        //                  "can_withdraw": true,
        //                  "deposit_least_amount": "4.9",
        //                  "withdraw_least_amount": "4.9",
        //                  "withdraw_tx_fee": "4.9",
        //                  "explorer_asset_url": "https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7"
        //             },
        //             ...
        //         },
        //         "message": "Success",
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object coins = new List<object>(((IDictionary<string,object>)data).Keys);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(coins)); postFixIncrement(ref i))
        {
            object coin = getValue(coins, i);
            object currency = getValue(data, coin);
            object currencyId = this.safeString(currency, "asset");
            object networkId = this.safeString(currency, "chain");
            object code = this.safeCurrencyCode(currencyId);
            object precisionString = this.parsePrecision(this.safeString(currency, "withdrawal_precision"));
            object precision = this.parseNumber(precisionString);
            object canDeposit = this.safeValue(currency, "can_deposit");
            object canWithdraw = this.safeValue(currency, "can_withdraw");
            object feeString = this.safeString(currency, "withdraw_tx_fee");
            object fee = this.parseNumber(feeString);
            object minNetworkDepositString = this.safeString(currency, "deposit_least_amount");
            object minNetworkDeposit = this.parseNumber(minNetworkDepositString);
            object minNetworkWithdrawString = this.safeString(currency, "withdraw_least_amount");
            object minNetworkWithdraw = this.parseNumber(minNetworkWithdrawString);
            if (isTrue(isEqual(this.safeValue(result, code), null)))
            {
                ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                    { "id", currencyId },
                    { "numericId", null },
                    { "code", code },
                    { "info", null },
                    { "name", null },
                    { "active", isTrue(canDeposit) && isTrue(canWithdraw) },
                    { "deposit", canDeposit },
                    { "withdraw", canWithdraw },
                    { "fee", fee },
                    { "precision", precision },
                    { "limits", new Dictionary<string, object>() {
                        { "amount", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", minNetworkDeposit },
                            { "max", null },
                        } },
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", minNetworkWithdraw },
                            { "max", null },
                        } },
                    } },
                };
            }
            object minFeeString = this.safeString(getValue(result, code), "fee");
            if (isTrue(!isEqual(feeString, null)))
            {
                minFeeString = ((bool) isTrue((isEqual(minFeeString, null)))) ? feeString : Precise.stringMin(feeString, minFeeString);
            }
            object depositAvailable = this.safeValue(getValue(result, code), "deposit");
            depositAvailable = ((bool) isTrue((canDeposit))) ? canDeposit : depositAvailable;
            object withdrawAvailable = this.safeValue(getValue(result, code), "withdraw");
            withdrawAvailable = ((bool) isTrue((canWithdraw))) ? canWithdraw : withdrawAvailable;
            object minDepositString = this.safeString(getValue(getValue(getValue(result, code), "limits"), "deposit"), "min");
            if (isTrue(!isEqual(minNetworkDepositString, null)))
            {
                minDepositString = ((bool) isTrue((isEqual(minDepositString, null)))) ? minNetworkDepositString : Precise.stringMin(minNetworkDepositString, minDepositString);
            }
            object minWithdrawString = this.safeString(getValue(getValue(getValue(result, code), "limits"), "withdraw"), "min");
            if (isTrue(!isEqual(minNetworkWithdrawString, null)))
            {
                minWithdrawString = ((bool) isTrue((isEqual(minWithdrawString, null)))) ? minNetworkWithdrawString : Precise.stringMin(minNetworkWithdrawString, minWithdrawString);
            }
            object minPrecisionString = this.safeString(getValue(result, code), "precision");
            if (isTrue(!isEqual(precisionString, null)))
            {
                minPrecisionString = ((bool) isTrue((isEqual(minPrecisionString, null)))) ? precisionString : Precise.stringMin(precisionString, minPrecisionString);
            }
            object networks = this.safeValue(getValue(result, code), "networks", new Dictionary<string, object>() {});
            object network = new Dictionary<string, object>() {
                { "info", currency },
                { "id", networkId },
                { "network", networkId },
                { "name", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", this.safeNumber(currency, "deposit_least_amount") },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.safeNumber(currency, "withdraw_least_amount") },
                        { "max", null },
                    } },
                } },
                { "active", isTrue(canDeposit) && isTrue(canWithdraw) },
                { "deposit", canDeposit },
                { "withdraw", canWithdraw },
                { "fee", fee },
                { "precision", precision },
            };
            ((IDictionary<string,object>)networks)[(string)networkId] = network;
            ((IDictionary<string,object>)getValue(result, code))["networks"] = networks;
            ((IDictionary<string,object>)getValue(result, code))["active"] = isTrue(depositAvailable) && isTrue(withdrawAvailable);
            ((IDictionary<string,object>)getValue(result, code))["deposit"] = depositAvailable;
            ((IDictionary<string,object>)getValue(result, code))["withdraw"] = withdrawAvailable;
            object info = this.safeValue(getValue(result, code), "info", new List<object>() {});
            ((IList<object>)info).Add(currency);
            ((IDictionary<string,object>)getValue(result, code))["info"] = info;
            ((IDictionary<string,object>)getValue(result, code))["fee"] = this.parseNumber(minFeeString);
            ((IDictionary<string,object>)getValue(result, code))["precision"] = this.parseNumber(minPrecisionString);
            ((IDictionary<string,object>)getValue(getValue(getValue(result, code), "limits"), "deposit"))["min"] = this.parseNumber(minDepositString);
            ((IDictionary<string,object>)getValue(getValue(getValue(result, code), "limits"), "withdraw"))["min"] = this.parseNumber(minWithdrawString);
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchMarkets
        * @description retrieves data on all markets for coinex
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot001_market002_all_market_info
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http006_market_list
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object promises = ((object)new List<object> {this.fetchSpotMarkets(parameters), this.fetchContractMarkets(parameters)});
        promises = ((object)await promiseAll(promises));
        object spotMarkets = getValue(promises, 0);
        object swapMarkets = getValue(promises, 1);
        return this.arrayConcat(spotMarkets, swapMarkets);
    }

    public async virtual Task<object> fetchSpotMarkets(object parameters)
    {
        object response = await this.publicGetMarketInfo(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "WAVESBTC": {
        //                 "name": "WAVESBTC",
        //                 "min_amount": "1",
        //                 "maker_fee_rate": "0.001",
        //                 "taker_fee_rate": "0.001",
        //                 "pricing_name": "BTC",
        //                 "pricing_decimal": 8,
        //                 "trading_name": "WAVES",
        //                 "trading_decimal": 8
        //             }
        //         }
        //     }
        //
        object markets = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object result = new List<object>() {};
        object keys = new List<object>(((IDictionary<string,object>)markets).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object market = getValue(markets, key);
            object id = this.safeString(market, "name");
            object tradingName = this.safeString(market, "trading_name");
            object baseId = tradingName;
            object quoteId = this.safeString(market, "pricing_name");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object symbol = add(add(bs, "/"), quote);
            if (isTrue(isEqual(tradingName, id)))
            {
                symbol = id;
            }
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", null },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", null },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", this.safeNumber(market, "taker_fee_rate") },
                { "maker", this.safeNumber(market, "maker_fee_rate") },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "trading_decimal"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "pricing_decimal"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_amount") },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", market },
            });
        }
        return result;
    }

    public async virtual Task<object> fetchContractMarkets(object parameters)
    {
        object response = await this.perpetualPublicGetMarketList(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "name": "BTCUSD",
        //                 "type": 2, // 1: USDT-M Contracts, 2: Coin-M Contracts
        //                 "leverages": ["3", "5", "8", "10", "15", "20", "30", "50", "100"],
        //                 "stock": "BTC",
        //                 "money": "USD",
        //                 "fee_prec": 5,
        //                 "stock_prec": 8,
        //                 "money_prec": 1,
        //                 "amount_prec": 0,
        //                 "amount_min": "10",
        //                 "multiplier": "1",
        //                 "tick_size": "0.1", // Min. Price Increment
        //                 "available": true
        //             },
        //         ],
        //         "message": "OK"
        //     }
        //
        object markets = this.safeValue(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object entry = getValue(markets, i);
            object fees = this.fees;
            object leverages = this.safeValue(entry, "leverages", new List<object>() {});
            object subType = this.safeInteger(entry, "type");
            object linear = (isEqual(subType, 1));
            object inverse = (isEqual(subType, 2));
            object id = this.safeString(entry, "name");
            object baseId = this.safeString(entry, "stock");
            object quoteId = this.safeString(entry, "money");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object settleId = ((bool) isTrue((isEqual(subType, 1)))) ? "USDT" : baseId;
            object settle = this.safeCurrencyCode(settleId);
            object symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
            object leveragesLength = getArrayLength(leverages);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", "swap" },
                { "spot", false },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "active", this.safeValue(entry, "available") },
                { "contract", true },
                { "linear", linear },
                { "inverse", inverse },
                { "taker", getValue(getValue(fees, "trading"), "taker") },
                { "maker", getValue(getValue(fees, "trading"), "maker") },
                { "contractSize", this.safeNumber(entry, "multiplier") },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(entry, "amount_prec"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(entry, "money_prec"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.safeNumber(leverages, 0) },
                        { "max", this.safeNumber(leverages, subtract(leveragesLength, 1)) },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(entry, "amount_min") },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "created", null },
                { "info", entry },
            });
        }
        return result;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // Spot fetchTicker, fetchTickers
        //
        //     {
        //         "vol": "293.19415130",
        //         "low": "38200.00",
        //         "open": "39514.99",
        //         "high": "39530.00",
        //         "last": "38649.57",
        //         "buy": "38640.20",
        //         "buy_amount": "0.22800000",
        //         "sell": "38640.21",
        //         "sell_amount": "0.02828439"
        //     }
        //
        // Swap fetchTicker, fetchTickers
        //
        //     {
        //         "vol": "7714.2175",
        //         "low": "38200.00",
        //         "open": "39569.23",
        //         "high": "39569.23",
        //         "last": "38681.37",
        //         "buy": "38681.36",
        //         "period": 86400,
        //         "funding_time": 462,
        //         "position_amount": "296.7552",
        //         "funding_rate_last": "0.00009395",
        //         "funding_rate_next": "0.00000649",
        //         "funding_rate_predict": "-0.00007176",
        //         "insurance": "16464465.09431942163278132918",
        //         "sign_price": "38681.93",
        //         "index_price": "38681.69500000",
        //         "sell_total": "16.6039",
        //         "buy_total": "19.8481",
        //         "buy_amount": "4.6315",
        //         "sell": "38681.37",
        //         "sell_amount": "11.4044"
        //     }
        //
        object timestamp = this.safeInteger(ticker, "date");
        object symbol = this.safeSymbol(null, market);
        ticker = this.safeValue(ticker, "ticker", new Dictionary<string, object>() {});
        object last = this.safeString(ticker, "last");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(ticker, "buy") },
            { "bidVolume", this.safeString(ticker, "buy_amount") },
            { "ask", this.safeString(ticker, "sell") },
            { "askVolume", this.safeString(ticker, "sell_amount") },
            { "vwap", null },
            { "open", this.safeString(ticker, "open") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString2(ticker, "vol", "volume") },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot001_market007_single_market_ticker
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http008_market_ticker
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.perpetualPublicGetMarketTicker(this.extend(request, parameters));
        } else
        {
            response = await this.publicGetMarketTicker(this.extend(request, parameters));
        }
        //
        // Spot
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "date": 1651306913414,
        //             "ticker": {
        //                 "vol": "293.19415130",
        //                 "low": "38200.00",
        //                 "open": "39514.99",
        //                 "high": "39530.00",
        //                 "last": "38649.57",
        //                 "buy": "38640.20",
        //                 "buy_amount": "0.22800000",
        //                 "sell": "38640.21",
        //                 "sell_amount": "0.02828439"
        //             }
        //         },
        //         "message": "OK"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "date": 1651306641500,
        //             "ticker": {
        //                 "vol": "7714.2175",
        //                 "low": "38200.00",
        //                 "open": "39569.23",
        //                 "high": "39569.23",
        //                 "last": "38681.37",
        //                 "buy": "38681.36",
        //                 "period": 86400,
        //                 "funding_time": 462,
        //                 "position_amount": "296.7552",
        //                 "funding_rate_last": "0.00009395",
        //                 "funding_rate_next": "0.00000649",
        //                 "funding_rate_predict": "-0.00007176",
        //                 "insurance": "16464465.09431942163278132918",
        //                 "sign_price": "38681.93",
        //                 "index_price": "38681.69500000",
        //                 "sell_total": "16.6039",
        //                 "buy_total": "19.8481",
        //                 "buy_amount": "4.6315",
        //                 "sell": "38681.37",
        //                 "sell_amount": "11.4044"
        //             }
        //         },
        //         "message": "OK"
        //     }
        //
        return this.parseTicker(getValue(response, "data"), market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTickers
        * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot001_market008_all_market_ticker
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http009_market_ticker_all
        * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = this.safeValue(symbols, 0);
            market = this.market(symbol);
        }
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        object response = null;
        if (isTrue(isEqual(marketType, "swap")))
        {
            response = await this.perpetualPublicGetMarketTickerAll(query);
        } else
        {
            response = await this.publicGetMarketTickerAll();
        }
        //
        // Spot
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "date": 1651519857284,
        //             "ticker": {
        //                 "PSPUSDT": {
        //                     "vol": "127131.55227034",
        //                     "low": "0.0669",
        //                     "open": "0.0688",
        //                     "high": "0.0747",
        //                     "last": "0.0685",
        //                     "buy": "0.0676",
        //                     "buy_amount": "702.70117866",
        //                     "sell": "0.0690",
        //                     "sell_amount": "686.76861562"
        //                 },
        //             }
        //         },
        //         "message": "Ok"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "date": 1651520268644,
        //             "ticker": {
        //                 "KAVAUSDT": {
        //                     "vol": "834924",
        //                     "low": "3.9418",
        //                     "open": "4.1834",
        //                     "high": "4.4328",
        //                     "last": "4.0516",
        //                     "buy": "4.0443",
        //                     "period": 86400,
        //                     "funding_time": 262,
        //                     "position_amount": "16111",
        //                     "funding_rate_last": "-0.00069514",
        //                     "funding_rate_next": "-0.00061009",
        //                     "funding_rate_predict": "-0.00055812",
        //                     "insurance": "16532425.53026084124483989548",
        //                     "sign_price": "4.0516",
        //                     "index_price": "4.0530",
        //                     "sell_total": "59446",
        //                     "buy_total": "62423",
        //                     "buy_amount": "959",
        //                     "sell": "4.0466",
        //                     "sell_amount": "141"
        //                 },
        //             }
        //         },
        //         "message": "Ok"
        //     }
        //
        object data = this.safeValue(response, "data");
        object timestamp = this.safeInteger(data, "date");
        object tickers = this.safeValue(data, "ticker", new Dictionary<string, object>() {});
        object marketIds = new List<object>(((IDictionary<string,object>)tickers).Keys);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = getValue(marketIds, i);
            object marketInner = this.safeMarket(marketId, null, null, marketType);
            object symbol = getValue(marketInner, "symbol");
            object ticker = this.parseTicker(new Dictionary<string, object>() {
                { "date", timestamp },
                { "ticker", getValue(tickers, marketId) },
            }, marketInner);
            ((IDictionary<string,object>)ticker)["symbol"] = symbol;
            ((IDictionary<string,object>)result)[(string)symbol] = ticker;
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http005_system_time
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.perpetualPublicGetTime(parameters);
        //
        //     {
        //         "code": "0",
        //         "data": "1653261274414",
        //         "message": "OK"
        //     }
        //
        return this.safeInteger(response, "data");
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot001_market004_market_depth
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http010_market_depth
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int} [limit] the maximum amount of order book entries to return
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        limit ??= 20;
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(isEqual(limit, null)))
        {
            limit = 20; // default
        }
        object request = new Dictionary<string, object>() {
            { "market", this.marketId(symbol) },
            { "merge", "0" },
            { "limit", ((object)limit).ToString() },
        };
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.perpetualPublicGetMarketDepth(this.extend(request, parameters));
        } else
        {
            response = await this.publicGetMarketDepth(this.extend(request, parameters));
        }
        //
        // Spot
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "asks": [
        //                 ["41056.33", "0.31727613"],
        //                 ["41056.34", "1.05657294"],
        //                 ["41056.35", "0.02346648"]
        //             ],
        //             "bids": [
        //                 ["41050.61", "0.40618608"],
        //                 ["41046.98", "0.13800000"],
        //                 ["41046.56", "0.22579234"]
        //             ],
        //             "last": "41050.61",
        //             "time": 1650573220346
        //         },
        //         "message": "OK"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "asks": [
        //                 ["40620.90", "0.0384"],
        //                 ["40625.50", "0.0219"],
        //                 ["40625.90", "0.3506"]
        //             ],
        //             "bids": [
        //                 ["40620.89", "19.6861"],
        //                 ["40620.80", "0.0012"],
        //                 ["40619.87", "0.0365"]
        //             ],
        //             "last": "40620.89",
        //             "time": 1650587672406,
        //             "sign_price": "40619.32",
        //             "index_price": "40609.93"
        //         },
        //         "message": "OK"
        //     }
        //
        object result = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(result, "time");
        return this.parseOrderBook(result, symbol, timestamp);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // Spot and Swap fetchTrades (public)
        //
        //      {
        //          "id":  2611511379,
        //          "type": "buy",
        //          "price": "192.63",
        //          "amount": "0.02266931",
        //          "date":  1638990110,
        //          "date_ms":  1638990110518
        //      },
        //
        // Spot and Margin fetchMyTrades (private)
        //
        //      {
        //          "id": 2611520950,
        //          "order_id": 63286573298,
        //          "account_id": 0,
        //          "create_time": 1638990636,
        //          "type": "sell",
        //          "role": "taker",
        //          "price": "192.29",
        //          "amount": "0.098",
        //          "fee": "0.03768884",
        //          "fee_asset": "USDT",
        //          "market": "AAVEUSDT",
        //          "deal_money": "18.84442"
        //      }
        //
        // Swap fetchMyTrades (private)
        //
        //     {
        //         "amount": "0.0012",
        //         "deal_fee": "0.0237528",
        //         "deal_insurance": "0",
        //         "deal_margin": "15.8352",
        //         "deal_order_id": 17797031903,
        //         "deal_profit": "0",
        //         "deal_stock": "47.5056",
        //         "deal_type": 1,
        //         "deal_user_id": 2969195,
        //         "fee_asset": "",
        //         "fee_discount": "0",
        //         "fee_price": "0",
        //         "fee_rate": "0.0005",
        //         "fee_real_rate": "0.0005",
        //         "id": 379044296,
        //         "leverage": "3",
        //         "margin_amount": "15.8352",
        //         "market": "BTCUSDT",
        //         "open_price": "39588",
        //         "order_id": 17797092987,
        //         "position_amount": "0.0012",
        //         "position_id": 62052321,
        //         "position_type": 1,
        //         "price": "39588",
        //         "role": 2,
        //         "side": 2,
        //         "time": 1650675936.016103,
        //         "user_id": 3620173
        //     }
        //
        object timestamp = this.safeTimestamp2(trade, "create_time", "time");
        if (isTrue(isEqual(timestamp, null)))
        {
            timestamp = this.safeInteger(trade, "date_ms");
        }
        object tradeId = this.safeString(trade, "id");
        object orderId = this.safeString(trade, "order_id");
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString(trade, "amount");
        object marketId = this.safeString(trade, "market");
        object marketType = this.safeString(trade, "market_type");
        object defaultType = ((bool) isTrue((isEqual(marketType, null)))) ? "spot" : "swap";
        market = this.safeMarket(marketId, market, null, defaultType);
        object symbol = getValue(market, "symbol");
        object costString = this.safeString(trade, "deal_money");
        object fee = null;
        object feeCostString = this.safeString2(trade, "fee", "deal_fee");
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCurrencyId = this.safeString(trade, "fee_asset");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", feeCurrencyCode },
            };
        }
        object takerOrMaker = this.safeString(trade, "role");
        if (isTrue(isEqual(takerOrMaker, "1")))
        {
            takerOrMaker = "maker";
        } else if (isTrue(isEqual(takerOrMaker, "2")))
        {
            takerOrMaker = "taker";
        }
        object side = null;
        if (isTrue(isEqual(getValue(market, "type"), "swap")))
        {
            object rawSide = this.safeInteger(trade, "side");
            if (isTrue(isEqual(rawSide, 1)))
            {
                side = "sell";
            } else if (isTrue(isEqual(rawSide, 2)))
            {
                side = "buy";
            }
            if (isTrue(isEqual(side, null)))
            {
                side = this.safeString(trade, "type");
            }
        } else
        {
            side = this.safeString(trade, "type");
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", tradeId },
            { "order", orderId },
            { "type", null },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", priceString },
            { "amount", amountString },
            { "cost", costString },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot001_market005_market_deals
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http011_market_deals
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int} [since] timestamp in ms of the earliest trade to fetch
        * @param {int} [limit] the maximum amount of trades to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.perpetualPublicGetMarketDeals(this.extend(request, parameters));
        } else
        {
            response = await this.publicGetMarketDeals(this.extend(request, parameters));
        }
        //
        // Spot and Swap
        //
        //      {
        //          "code":    0,
        //          "data": [
        //              {
        //                  "id":  2611511379,
        //                  "type": "buy",
        //                  "price": "192.63",
        //                  "amount": "0.02266931",
        //                  "date":  1638990110,
        //                  "date_ms":  1638990110518
        //                  },
        //              ],
        //          "message": "OK"
        //      }
        //
        return this.parseTrades(getValue(response, "data"), market, since, limit);
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTradingFee
        * @description fetch the trading fees for a market
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot001_market003_single_market_info
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = await this.publicGetMarketDetail(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //           "name": "BTCUSDC",
        //           "min_amount": "0.0005",
        //           "maker_fee_rate": "0.002",
        //           "taker_fee_rate": "0.002",
        //           "pricing_name": "USDC",
        //           "pricing_decimal": 2,
        //           "trading_name": "BTC",
        //           "trading_decimal": 8
        //         },
        //         "message": "OK"
        //      }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseTradingFee(data, market);
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot001_market002_all_market_info
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetMarketInfo(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "WAVESBTC": {
        //                 "name": "WAVESBTC",
        //                 "min_amount": "1",
        //                 "maker_fee_rate": "0.001",
        //                 "taker_fee_rate": "0.001",
        //                 "pricing_name": "BTC",
        //                 "pricing_decimal": 8,
        //                 "trading_name": "WAVES",
        //                 "trading_decimal": 8
        //             }
        //             ...
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(this.symbols, i);
            object market = this.market(symbol);
            object fee = this.safeValue(data, getValue(market, "id"), new Dictionary<string, object>() {});
            ((IDictionary<string,object>)result)[(string)symbol] = this.parseTradingFee(fee, market);
        }
        return result;
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        object marketId = this.safeValue(fee, "name");
        object symbol = this.safeSymbol(marketId, market);
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", symbol },
            { "maker", this.safeNumber(fee, "maker_fee_rate") },
            { "taker", this.safeNumber(fee, "taker_fee_rate") },
            { "percentage", true },
            { "tierBased", true },
        };
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         1591484400,
        //         "0.02505349",
        //         "0.02506988",
        //         "0.02507000",
        //         "0.02505304",
        //         "343.19716223",
        //         "8.6021323866383196",
        //         "ETHBTC"
        //     ]
        //
        return new List<object> {this.safeTimestamp(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 5)};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot001_market006_market_kline
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http012_market_kline
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "type", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = null;
        if (isTrue(getValue(market, "swap")))
        {
            response = await this.perpetualPublicGetMarketKline(this.extend(request, parameters));
        } else
        {
            response = await this.publicGetMarketKline(this.extend(request, parameters));
        }
        //
        // Spot
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             [1591484400, "0.02505349", "0.02506988", "0.02507000", "0.02505304", "343.19716223", "8.6021323866383196", "ETHBTC"],
        //             [1591484700, "0.02506990", "0.02508109", "0.02508109", "0.02506979", "91.59841581", "2.2972047780447000", "ETHBTC"],
        //             [1591485000, "0.02508106", "0.02507996", "0.02508106", "0.02507500", "65.15307697", "1.6340597822306000", "ETHBTC"],
        //         ],
        //         "message": "OK"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             [1650569400, "41524.64", "41489.31", "41564.61", "41480.58", "29.7060", "1233907.099562"],
        //             [1650569700, "41489.31", "41438.29", "41489.31", "41391.87", "42.4115", "1756154.189061"],
        //             [1650570000, "41438.29", "41482.21", "41485.05", "41427.31", "22.2892", "924000.317861"]
        //         ],
        //         "message": "OK"
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public async virtual Task<object> fetchMarginBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object symbol = this.safeString(parameters, "symbol");
        object marketId = this.safeString(parameters, "market");
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            marketId = getValue(market, "id");
        } else if (isTrue(isEqual(marketId, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMarginBalance() fetching a margin account requires a market parameter or a symbol parameter")) ;
        }
        parameters = this.omit(parameters, new List<object>() {"symbol", "market"});
        object request = new Dictionary<string, object>() {
            { "market", marketId },
        };
        object response = await this.privateGetMarginAccount(this.extend(request, parameters));
        //
        //      {
        //          "code":    0,
        //           "data": {
        //              "account_id":    126,
        //              "leverage":    3,
        //              "market_type":   "AAVEUSDT",
        //              "sell_asset_type":   "AAVE",
        //              "buy_asset_type":   "USDT",
        //              "balance": {
        //                  "sell_type": "0.3",     // borrowed
        //                  "buy_type": "30"
        //                  },
        //              "frozen": {
        //                  "sell_type": "0",
        //                  "buy_type": "0"
        //                  },
        //              "loan": {
        //                  "sell_type": "0.3", // loan
        //                  "buy_type": "0"
        //                  },
        //              "interest": {
        //                  "sell_type": "0.0000125",
        //                  "buy_type": "0"
        //                  },
        //              "can_transfer": {
        //                  "sell_type": "0.02500646",
        //                  "buy_type": "4.28635738"
        //                  },
        //              "warn_rate":   "",
        //              "liquidation_price":   ""
        //              },
        //          "message": "Success"
        //      }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object free = this.safeValue(data, "can_transfer", new Dictionary<string, object>() {});
        object total = this.safeValue(data, "balance", new Dictionary<string, object>() {});
        object loan = this.safeValue(data, "loan", new Dictionary<string, object>() {});
        object interest = this.safeValue(data, "interest", new Dictionary<string, object>() {});
        //
        object sellAccount = this.account();
        object sellCurrencyId = this.safeString(data, "sell_asset_type");
        object sellCurrencyCode = this.safeCurrencyCode(sellCurrencyId);
        ((IDictionary<string,object>)sellAccount)["free"] = this.safeString(free, "sell_type");
        ((IDictionary<string,object>)sellAccount)["total"] = this.safeString(total, "sell_type");
        object sellDebt = this.safeString(loan, "sell_type");
        object sellInterest = this.safeString(interest, "sell_type");
        ((IDictionary<string,object>)sellAccount)["debt"] = Precise.stringAdd(sellDebt, sellInterest);
        ((IDictionary<string,object>)result)[(string)sellCurrencyCode] = sellAccount;
        //
        object buyAccount = this.account();
        object buyCurrencyId = this.safeString(data, "buy_asset_type");
        object buyCurrencyCode = this.safeCurrencyCode(buyCurrencyId);
        ((IDictionary<string,object>)buyAccount)["free"] = this.safeString(free, "buy_type");
        ((IDictionary<string,object>)buyAccount)["total"] = this.safeString(total, "buy_type");
        object buyDebt = this.safeString(loan, "buy_type");
        object buyInterest = this.safeString(interest, "buy_type");
        ((IDictionary<string,object>)buyAccount)["debt"] = Precise.stringAdd(buyDebt, buyInterest);
        ((IDictionary<string,object>)result)[(string)buyCurrencyCode] = buyAccount;
        //
        return this.safeBalance(result);
    }

    public async virtual Task<object> fetchSpotBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetBalanceInfo(parameters);
        //
        //     {
        //       "code": 0,
        //       "data": {
        //         "BCH": {                     # BCH account
        //           "available": "13.60109",   # Available BCH
        //           "frozen": "0.00000"        # Frozen BCH
        //         },
        //         "BTC": {                     # BTC account
        //           "available": "32590.16",   # Available BTC
        //           "frozen": "7000.00"        # Frozen BTC
        //         },
        //         "ETH": {                     # ETH account
        //           "available": "5.06000",    # Available ETH
        //           "frozen": "0.00000"        # Frozen ETH
        //         }
        //       },
        //       "message": "Ok"
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object balances = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object currencyIds = new List<object>(((IDictionary<string,object>)balances).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencyIds, i);
            object code = this.safeCurrencyCode(currencyId);
            object balance = this.safeValue(balances, currencyId, new Dictionary<string, object>() {});
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "available");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "frozen");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async virtual Task<object> fetchSwapBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.perpetualPrivateGetAssetQuery(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "USDT": {
        //                 "available": "37.24817690383456000000",
        //                 "balance_total": "37.24817690383456000000",
        //                 "frozen": "0.00000000000000000000",
        //                 "margin": "0.00000000000000000000",
        //                 "profit_unreal": "0.00000000000000000000",
        //                 "transfer": "37.24817690383456000000"
        //             }
        //         },
        //         "message": "OK"
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object balances = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object currencyIds = new List<object>(((IDictionary<string,object>)balances).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencyIds, i);
            object code = this.safeCurrencyCode(currencyId);
            object balance = this.safeValue(balances, currencyId, new Dictionary<string, object>() {});
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "available");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balance, "frozen");
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "balance_total");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async virtual Task<object> fetchFinancialBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetAccountInvestmentBalance(parameters);
        //
        //     {
        //          "code": 0,
        //          "data": [
        //              {
        //                  "asset": "CET",
        //                  "available": "0",
        //                  "frozen": "0",
        //                  "lock": "0",
        //              },
        //              {
        //                  "asset": "USDT",
        //                  "available": "999900",
        //                  "frozen": "0",
        //                  "lock": "0"
        //              }
        //          ],
        //          "message": "Success"
        //      }
        //
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object balances = this.safeValue(response, "data", new Dictionary<string, object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object currencyId = this.safeString(balance, "asset");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "available");
            object frozen = this.safeString(balance, "frozen");
            object locked = this.safeString(balance, "lock");
            ((IDictionary<string,object>)account)["used"] = Precise.stringAdd(frozen, locked);
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account001_account_info         // spot
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account004_investment_balance   // financial
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account006_margin_account       // margin
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http016_asset_query       // swap
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.type] 'margin', 'swap', 'financial', or 'spot'
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        marketType = ((IList<object>)marketTypeparametersVariable)[0];
        parameters = ((IList<object>)marketTypeparametersVariable)[1];
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBalance", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        marketType = ((bool) isTrue((!isEqual(marginMode, null)))) ? "margin" : marketType;
        parameters = this.omit(parameters, "margin");
        if (isTrue(isEqual(marketType, "margin")))
        {
            return await this.fetchMarginBalance(parameters);
        } else if (isTrue(isEqual(marketType, "swap")))
        {
            return await this.fetchSwapBalance(parameters);
        } else if (isTrue(isEqual(marketType, "financial")))
        {
            return await this.fetchFinancialBalance(parameters);
        } else
        {
            return await this.fetchSpotBalance(parameters);
        }
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "rejected", "rejected" },
            { "open", "open" },
            { "not_deal", "open" },
            { "part_deal", "open" },
            { "done", "closed" },
            { "cancel", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // fetchOrder
        //
        //     {
        //         "amount": "0.1",
        //         "asset_fee": "0.22736197736197736197",
        //         "avg_price": "196.85000000000000000000",
        //         "create_time": 1537270135,
        //         "deal_amount": "0.1",
        //         "deal_fee": "0",
        //         "deal_money": "19.685",
        //         "fee_asset": "CET",
        //         "fee_discount": "0.5",
        //         "id": 1788259447,
        //         "left": "0",
        //         "maker_fee_rate": "0",
        //         "market": "ETHUSDT",
        //         "order_type": "limit",
        //         "price": "170.00000000",
        //         "status": "done",
        //         "taker_fee_rate": "0.0005",
        //         "type": "sell",
        //         "client_id": "",
        //     }
        //
        // Spot and Margin createOrder, createOrders, cancelOrder, cancelOrders, fetchOrder
        //
        //      {
        //          "amount":"1.5",
        //          "asset_fee":"0",
        //          "avg_price":"0.14208538",
        //          "client_id":"",
        //          "create_time":1650993819,
        //          "deal_amount":"10.55703267",
        //          "deal_fee":"0.0029999999971787292",
        //          "deal_money":"1.4999999985893646",
        //          "fee_asset":null,
        //          "fee_discount":"1",
        //          "finished_time":null,
        //          "id":74556296907,
        //          "left":"0.0000000014106354",
        //          "maker_fee_rate":"0",
        //          "market":"DOGEUSDT",
        //          "money_fee":"0.0029999999971787292",
        //          "order_type":"market",
        //          "price":"0",
        //          "status":"done",
        //          "stock_fee":"0",
        //          "taker_fee_rate":"0.002",
        //          "type":"buy"
        //          "client_id": "",
        //      }
        //
        // Swap createOrder, cancelOrder, fetchOrder
        //
        //     {
        //         "amount": "0.0005",
        //         "client_id": "",
        //         "create_time": 1651004578.618224,
        //         "deal_asset_fee": "0.00000000000000000000",
        //         "deal_fee": "0.00000000000000000000",
        //         "deal_profit": "0.00000000000000000000",
        //         "deal_stock": "0.00000000000000000000",
        //         "effect_type": 1,
        //         "fee_asset": "",
        //         "fee_discount": "0.00000000000000000000",
        //         "last_deal_amount": "0.00000000000000000000",
        //         "last_deal_id": 0,
        //         "last_deal_price": "0.00000000000000000000",
        //         "last_deal_role": 0,
        //         "last_deal_time": 0,
        //         "last_deal_type": 0,
        //         "left": "0.0005",
        //         "leverage": "3",
        //         "maker_fee": "0.00030",
        //         "market": "BTCUSDT",
        //         "order_id": 18221659097,
        //         "position_id": 0,
        //         "position_type": 1,
        //         "price": "30000.00",
        //         "side": 2,
        //         "source": "api.v1",
        //         "stop_id": 0,
        //         "taker_fee": "0.00050",
        //         "target": 0,
        //         "type": 1,
        //         "update_time": 1651004578.618224,
        //         "user_id": 3620173
        //     }
        //
        // Stop order createOrder
        //
        //     {"status":"success"}
        //
        // Swap Stop cancelOrder, fetchOrder
        //
        //     {
        //         "amount": "0.0005",
        //         "client_id": "",
        //         "create_time": 1651034023.008771,
        //         "effect_type": 1,
        //         "fee_asset": "",
        //         "fee_discount": "0.00000000000000000000",
        //         "maker_fee": "0.00030",
        //         "market": "BTCUSDT",
        //         "order_id": 18256915101,
        //         "price": "31000.00",
        //         "side": 2,
        //         "source": "api.v1",
        //         "state": 1,
        //         "stop_price": "31500.00",
        //         "stop_type": 1,
        //         "taker_fee": "0.00050",
        //         "target": 0,
        //         "type": 1,
        //         "update_time": 1651034397.193624,
        //         "user_id": 3620173
        //     }
        //
        //
        // Spot and Margin fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "account_id": 0,
        //         "amount": "0.0005",
        //         "asset_fee": "0",
        //         "avg_price": "0.00",
        //         "client_id": "",
        //         "create_time": 1651089247,
        //         "deal_amount": "0",
        //         "deal_fee": "0",
        //         "deal_money": "0",
        //         "fee_asset": null,
        //         "fee_discount": "1",
        //         "finished_time": 0,
        //         "id": 74660190839,
        //         "left": "0.0005",
        //         "maker_fee_rate": "0.002",
        //         "market": "BTCUSDT",
        //         "money_fee": "0",
        //         "order_type": "limit",
        //         "price": "31000",
        //         "status": "not_deal",
        //         "stock_fee": "0",
        //         "taker_fee_rate": "0.002",
        //         "type": "buy"
        //     }
        //
        // Swap fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "amount": "0.0005",
        //         "client_id": "",
        //         "create_time": 1651030414.088431,
        //         "deal_asset_fee": "0",
        //         "deal_fee": "0.00960069",
        //         "deal_profit": "0.009825",
        //         "deal_stock": "19.20138",
        //         "effect_type": 0,
        //         "fee_asset": "",
        //         "fee_discount": "0",
        //         "left": "0",
        //         "leverage": "3",
        //         "maker_fee": "0",
        //         "market": "BTCUSDT",
        //         "order_id": 18253447431,
        //         "position_id": 0,
        //         "position_type": 1,
        //         "price": "0",
        //         "side": 1,
        //         "source": "web",
        //         "stop_id": 0,
        //         "taker_fee": "0.0005",
        //         "target": 0,
        //         "type": 2,
        //         "update_time": 1651030414.08847,
        //         "user_id": 3620173
        //     }
        //
        // Spot and Margin Stop fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "account_id": 0,
        //         "amount": "155",
        //         "client_id": "",
        //         "create_time": 1651089182,
        //         "fee_asset": null,
        //         "fee_discount": "1",
        //         "maker_fee": "0.002",
        //         "market": "BTCUSDT",
        //         "order_id": 74660111965,
        //         "order_type": "market",
        //         "price": "0",
        //         "state": 0,
        //         "stop_price": "31500",
        //         "taker_fee": "0.002",
        //         "type": "buy"
        //     }
        //
        // Swap Stop fetchOpenOrders
        //
        //     {
        //         "amount": "0.0005",
        //         "client_id": "",
        //         "create_time": 1651089147.321691,
        //         "effect_type": 1,
        //         "fee_asset": "",
        //         "fee_discount": "0.00000000000000000000",
        //         "maker_fee": "0.00030",
        //         "market": "BTCUSDT",
        //         "order_id": 18332143848,
        //         "price": "31000.00",
        //         "side": 2,
        //         "source": "api.v1",
        //         "state": 1,
        //         "stop_price": "31500.00",
        //         "stop_type": 1,
        //         "taker_fee": "0.00050",
        //         "target": 0,
        //         "type": 1,
        //         "update_time": 1651089147.321691,
        //         "user_id": 3620173
        //     }
        //
        // swap: cancelOrders
        //
        //     {
        //         "amount": "0.0005",
        //         "client_id": "x-167673045-b0cee0c584718b65",
        //         "create_time": 1701233683.294231,
        //         "deal_asset_fee": "0.00000000000000000000",
        //         "deal_fee": "0.00000000000000000000",
        //         "deal_profit": "0.00000000000000000000",
        //         "deal_stock": "0.00000000000000000000",
        //         "effect_type": 1,
        //         "fee_asset": "",
        //         "fee_discount": "0.00000000000000000000",
        //         "last_deal_amount": "0.00000000000000000000",
        //         "last_deal_id": 0,
        //         "last_deal_price": "0.00000000000000000000",
        //         "last_deal_role": 0,
        //         "last_deal_time": 0,
        //         "last_deal_type": 0,
        //         "left": "0.0005",
        //         "leverage": "3",
        //         "maker_fee": "0.00030",
        //         "market": "BTCUSDT",
        //         "option": 0,
        //         "order_id": 115940476323,
        //         "position_id": 0,
        //         "position_type": 2,
        //         "price": "25000.00",
        //         "side": 2,
        //         "source": "api.v1",
        //         "stop_id": 0,
        //         "stop_loss_price": "0.00000000000000000000",
        //         "stop_loss_type": 0,
        //         "take_profit_price": "0.00000000000000000000",
        //         "take_profit_type": 0,
        //         "taker_fee": "0.00050",
        //         "target": 0,
        //         "type": 1,
        //         "update_time": 1701233721.718884,
        //         "user_id": 3620173
        //     }
        //
        object rawStatus = this.safeString(order, "status");
        object timestamp = this.safeTimestamp(order, "create_time");
        object marketId = this.safeString(order, "market");
        object defaultType = this.safeString(this.options, "defaultType");
        object orderType = ((bool) isTrue((inOp(order, "source")))) ? "swap" : defaultType;
        market = this.safeMarket(marketId, market, null, orderType);
        object feeCurrencyId = this.safeString(order, "fee_asset");
        object feeCurrency = this.safeCurrencyCode(feeCurrencyId);
        if (isTrue(isEqual(feeCurrency, null)))
        {
            feeCurrency = getValue(market, "quote");
        }
        object rawSide = this.safeInteger(order, "side");
        object side = null;
        if (isTrue(isEqual(rawSide, 1)))
        {
            side = "sell";
        } else if (isTrue(isEqual(rawSide, 2)))
        {
            side = "buy";
        } else
        {
            side = this.safeString(order, "type");
        }
        object rawType = this.safeString(order, "order_type");
        object type = null;
        if (isTrue(isEqual(rawType, null)))
        {
            object typeInteger = this.safeInteger(order, "type");
            if (isTrue(isEqual(typeInteger, 1)))
            {
                type = "limit";
            } else if (isTrue(isEqual(typeInteger, 2)))
            {
                type = "market";
            }
        } else
        {
            type = rawType;
        }
        object clientOrderId = this.safeString(order, "client_id");
        if (isTrue(isEqual(clientOrderId, "")))
        {
            clientOrderId = null;
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString2(order, "id", "order_id") },
            { "clientOrderId", clientOrderId },
            { "datetime", this.iso8601(timestamp) },
            { "timestamp", timestamp },
            { "lastTradeTimestamp", this.safeTimestamp(order, "update_time") },
            { "status", this.parseOrderStatus(rawStatus) },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", null },
            { "reduceOnly", null },
            { "side", side },
            { "price", this.safeString(order, "price") },
            { "stopPrice", this.safeString(order, "stop_price") },
            { "triggerPrice", this.safeString(order, "stop_price") },
            { "takeProfitPrice", this.safeNumber(order, "take_profit_price") },
            { "stopLossPrice", this.safeNumber(order, "stop_loss_price") },
            { "cost", this.safeString(order, "deal_money") },
            { "average", this.safeString(order, "avg_price") },
            { "amount", this.safeString(order, "amount") },
            { "filled", this.safeString(order, "deal_amount") },
            { "remaining", this.safeString(order, "left") },
            { "trades", null },
            { "fee", new Dictionary<string, object>() {
                { "currency", feeCurrency },
                { "cost", this.safeString(order, "deal_fee") },
            } },
            { "info", order },
        }, market);
    }

    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        /**
        * @method
        * @name coinex#createMarketBuyOrderWithCost
        * @description create a market buy order by providing the symbol and cost
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade003_market_order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {float} cost how much you want to trade in units of the quote currency
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
        }
        ((IDictionary<string,object>)parameters)["createMarketBuyOrderRequiresPrice"] = false;
        return await this.createOrder(symbol, "market", "buy", cost, null, parameters);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object swap = getValue(market, "swap");
        object clientOrderId = this.safeString2(parameters, "client_id", "clientOrderId");
        object stopPrice = this.safeValue2(parameters, "stopPrice", "triggerPrice");
        object stopLossPrice = this.safeValue(parameters, "stopLossPrice");
        object takeProfitPrice = this.safeValue(parameters, "takeProfitPrice");
        object option = this.safeString(parameters, "option");
        object isMarketOrder = isEqual(type, "market");
        object postOnly = this.isPostOnly(isMarketOrder, isEqual(option, "MAKER_ONLY"), parameters);
        object positionId = this.safeInteger2(parameters, "position_id", "positionId"); // Required for closing swap positions
        object timeInForceRaw = this.safeString(parameters, "timeInForce"); // Spot: IOC, FOK, PO, GTC, ... NORMAL (default), MAKER_ONLY
        object reduceOnly = this.safeValue(parameters, "reduceOnly");
        if (isTrue(reduceOnly))
        {
            if (!isTrue(getValue(market, "swap")))
            {
                throw new InvalidOrder ((string)add(add(add(this.id, " createOrder() does not support reduceOnly for "), getValue(market, "type")), " orders, reduceOnly orders are supported for swap markets only")) ;
            }
            if (isTrue(isEqual(positionId, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " createOrder() requires a position_id/positionId parameter for reduceOnly orders")) ;
            }
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        if (isTrue(isEqual(clientOrderId, null)))
        {
            object defaultId = "x-167673045";
            object brokerId = this.safeString(this.options, "brokerId", defaultId);
            ((IDictionary<string,object>)request)["client_id"] = add(add(brokerId, "-"), this.uuid16());
        } else
        {
            ((IDictionary<string,object>)request)["client_id"] = clientOrderId;
        }
        if (isTrue(swap))
        {
            if (isTrue(isTrue(stopLossPrice) || isTrue(takeProfitPrice)))
            {
                ((IDictionary<string,object>)request)["stop_type"] = this.safeInteger(parameters, "stop_type", 1); // 1: triggered by the latest transaction, 2: mark price, 3: index price
                if (isTrue(isEqual(positionId, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " createOrder() requires a position_id parameter for stop loss and take profit orders")) ;
                }
                ((IDictionary<string,object>)request)["position_id"] = positionId;
                if (isTrue(stopLossPrice))
                {
                    ((IDictionary<string,object>)request)["stop_loss_price"] = this.priceToPrecision(symbol, stopLossPrice);
                } else if (isTrue(takeProfitPrice))
                {
                    ((IDictionary<string,object>)request)["take_profit_price"] = this.priceToPrecision(symbol, takeProfitPrice);
                }
            } else
            {
                object requestSide = ((bool) isTrue((isEqual(side, "buy")))) ? 2 : 1;
                if (isTrue(!isEqual(stopPrice, null)))
                {
                    ((IDictionary<string,object>)request)["stop_price"] = this.priceToPrecision(symbol, stopPrice);
                    ((IDictionary<string,object>)request)["stop_type"] = this.safeInteger(parameters, "stop_type", 1); // 1: triggered by the latest transaction, 2: mark price, 3: index price;
                    ((IDictionary<string,object>)request)["amount"] = this.amountToPrecision(symbol, amount);
                    ((IDictionary<string,object>)request)["side"] = requestSide;
                    if (isTrue(isEqual(type, "limit")))
                    {
                        ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
                    }
                    ((IDictionary<string,object>)request)["amount"] = this.amountToPrecision(symbol, amount);
                }
                object timeInForce = null;
                if (isTrue(isTrue((!isEqual(type, "market"))) || isTrue((!isEqual(stopPrice, null)))))
                {
                    if (isTrue(postOnly))
                    {
                        ((IDictionary<string,object>)request)["option"] = 1;
                    } else if (isTrue(!isEqual(timeInForceRaw, null)))
                    {
                        if (isTrue(isEqual(timeInForceRaw, "IOC")))
                        {
                            timeInForce = 2;
                        } else if (isTrue(isEqual(timeInForceRaw, "FOK")))
                        {
                            timeInForce = 3;
                        } else
                        {
                            timeInForce = 1;
                        }
                        ((IDictionary<string,object>)request)["effect_type"] = timeInForce; // exchange takes 'IOC' and 'FOK'
                    }
                }
                if (isTrue(isTrue(isEqual(type, "limit")) && isTrue(isEqual(stopPrice, null))))
                {
                    if (isTrue(reduceOnly))
                    {
                        ((IDictionary<string,object>)request)["position_id"] = positionId;
                    } else
                    {
                        ((IDictionary<string,object>)request)["side"] = requestSide;
                    }
                    ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
                    ((IDictionary<string,object>)request)["amount"] = this.amountToPrecision(symbol, amount);
                } else if (isTrue(isTrue(isEqual(type, "market")) && isTrue(isEqual(stopPrice, null))))
                {
                    if (isTrue(reduceOnly))
                    {
                        ((IDictionary<string,object>)request)["position_id"] = positionId;
                    } else
                    {
                        ((IDictionary<string,object>)request)["side"] = requestSide;
                        ((IDictionary<string,object>)request)["amount"] = this.amountToPrecision(symbol, amount);
                    }
                }
            }
        } else
        {
            ((IDictionary<string,object>)request)["type"] = side;
            if (isTrue(isTrue((isEqual(type, "market"))) && isTrue((isEqual(side, "buy")))))
            {
                object createMarketBuyOrderRequiresPrice = true;
                var createMarketBuyOrderRequiresPriceparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                createMarketBuyOrderRequiresPrice = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[0];
                parameters = ((IList<object>)createMarketBuyOrderRequiresPriceparametersVariable)[1];
                object cost = this.safeNumber(parameters, "cost");
                parameters = this.omit(parameters, "cost");
                if (isTrue(createMarketBuyOrderRequiresPrice))
                {
                    if (isTrue(isTrue((isEqual(price, null))) && isTrue((isEqual(cost, null)))))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")) ;
                    } else
                    {
                        object amountString = this.numberToString(amount);
                        object priceString = this.numberToString(price);
                        object quoteAmount = this.parseToNumeric(Precise.stringMul(amountString, priceString));
                        object costRequest = ((bool) isTrue((!isEqual(cost, null)))) ? cost : quoteAmount;
                        ((IDictionary<string,object>)request)["amount"] = this.costToPrecision(symbol, costRequest);
                    }
                } else
                {
                    ((IDictionary<string,object>)request)["amount"] = this.costToPrecision(symbol, amount);
                }
            } else
            {
                ((IDictionary<string,object>)request)["amount"] = this.amountToPrecision(symbol, amount);
            }
            if (isTrue(isTrue((isEqual(type, "limit"))) || isTrue((isEqual(type, "ioc")))))
            {
                ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
            }
            if (isTrue(!isEqual(stopPrice, null)))
            {
                ((IDictionary<string,object>)request)["stop_price"] = this.priceToPrecision(symbol, stopPrice);
            }
            if (isTrue(isTrue((!isEqual(type, "market"))) || isTrue((!isEqual(stopPrice, null)))))
            {
                // following options cannot be applied to vanilla market orders (but can be applied to stop-market orders)
                if (isTrue(isTrue((!isEqual(timeInForceRaw, null))) || isTrue(postOnly)))
                {
                    if (isTrue(isTrue((isTrue(postOnly) || isTrue((!isEqual(timeInForceRaw, "IOC"))))) && isTrue((isTrue((isEqual(type, "limit"))) && isTrue((!isEqual(stopPrice, null)))))))
                    {
                        throw new InvalidOrder ((string)add(this.id, " createOrder() only supports the IOC option for stop-limit orders")) ;
                    }
                    if (isTrue(postOnly))
                    {
                        ((IDictionary<string,object>)request)["option"] = "MAKER_ONLY";
                    } else
                    {
                        if (isTrue(!isEqual(timeInForceRaw, null)))
                        {
                            ((IDictionary<string,object>)request)["option"] = timeInForceRaw; // exchange takes 'IOC' and 'FOK'
                        }
                    }
                }
            }
        }
        object accountId = this.safeInteger(parameters, "account_id");
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            if (isTrue(isEqual(accountId, null)))
            {
                throw new BadRequest ((string)add(this.id, " createOrder() requires an account_id parameter for margin orders")) ;
            }
            ((IDictionary<string,object>)request)["account_id"] = accountId;
        }
        parameters = this.omit(parameters, new List<object>() {"reduceOnly", "positionId", "timeInForce", "postOnly", "stopPrice", "triggerPrice", "stopLossPrice", "takeProfitPrice"});
        return this.extend(request, parameters);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#createOrder
        * @description create a trade order
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade001_limit_order
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade003_market_order
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade004_IOC_order
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade005_stop_limit_order
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade006_stop_market_order
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http017_put_limit
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http018_put_market
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http019_put_limit_stop
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http020_put_market_stop
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http031_market_close
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http030_limit_close
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {float} [params.triggerPrice] price to trigger stop orders
        * @param {float} [params.stopLossPrice] price to trigger stop loss orders
        * @param {float} [params.takeProfitPrice] price to trigger take profit orders
        * @param {string} [params.timeInForce] 'GTC', 'IOC', 'FOK', 'PO'
        * @param {boolean} [params.postOnly] set to true if you wish to make a post only order
        * @param {boolean} [params.reduceOnly] *contract only* indicates if this order is to reduce the size of a position
        * @param {int} [params.position_id] *required for reduce only orders* the position id to reduce
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object reduceOnly = this.safeValue(parameters, "reduceOnly");
        object triggerPrice = this.safeNumber2(parameters, "stopPrice", "triggerPrice");
        object stopLossTriggerPrice = this.safeNumber(parameters, "stopLossPrice");
        object takeProfitTriggerPrice = this.safeNumber(parameters, "takeProfitPrice");
        object isTriggerOrder = !isEqual(triggerPrice, null);
        object isStopLossTriggerOrder = !isEqual(stopLossTriggerPrice, null);
        object isTakeProfitTriggerOrder = !isEqual(takeProfitTriggerPrice, null);
        object isStopLossOrTakeProfitTrigger = isTrue(isStopLossTriggerOrder) || isTrue(isTakeProfitTriggerOrder);
        object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            if (isTrue(isTriggerOrder))
            {
                if (isTrue(isEqual(type, "limit")))
                {
                    response = await this.privatePostOrderStopLimit(request);
                } else
                {
                    response = await this.privatePostOrderStopMarket(request);
                }
            } else
            {
                if (isTrue(isEqual(type, "limit")))
                {
                    response = await this.privatePostOrderLimit(request);
                } else
                {
                    response = await this.privatePostOrderMarket(request);
                }
            }
        } else
        {
            if (isTrue(isTriggerOrder))
            {
                if (isTrue(isEqual(type, "limit")))
                {
                    response = await this.perpetualPrivatePostOrderPutStopLimit(request);
                } else
                {
                    response = await this.perpetualPrivatePostOrderPutStopMarket(request);
                }
            } else if (isTrue(isStopLossOrTakeProfitTrigger))
            {
                if (isTrue(isStopLossTriggerOrder))
                {
                    response = await this.perpetualPrivatePostPositionStopLoss(request);
                } else if (isTrue(isTakeProfitTriggerOrder))
                {
                    response = await this.perpetualPrivatePostPositionTakeProfit(request);
                }
            } else
            {
                if (isTrue(reduceOnly))
                {
                    if (isTrue(isEqual(type, "limit")))
                    {
                        response = await this.perpetualPrivatePostOrderCloseLimit(request);
                    } else
                    {
                        response = await this.perpetualPrivatePostOrderCloseMarket(request);
                    }
                } else
                {
                    if (isTrue(isEqual(type, "limit")))
                    {
                        response = await this.perpetualPrivatePostOrderPutLimit(request);
                    } else
                    {
                        response = await this.perpetualPrivatePostOrderPutMarket(request);
                    }
                }
            }
        }
        //
        // Spot and Margin
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "amount": "0.0005",
        //             "asset_fee": "0",
        //             "avg_price": "0.00",
        //             "client_id": "",
        //             "create_time": 1650951627,
        //             "deal_amount": "0",
        //             "deal_fee": "0",
        //             "deal_money": "0",
        //             "fee_asset": null,
        //             "fee_discount": "1",
        //             "finished_time": null,
        //             "id": 74510932594,
        //             "left": "0.0005",
        //             "maker_fee_rate": "0.002",
        //             "market": "BTCUSDT",
        //             "money_fee": "0",
        //             "order_type": "limit",
        //             "price": "30000",
        //             "status": "not_deal",
        //             "stock_fee": "0",
        //             "taker_fee_rate": "0.002",
        //             "type": "buy"
        //         },
        //         "message": "Success"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "amount": "0.0005",
        //             "client_id": "",
        //             "create_time": 1651004578.618224,
        //             "deal_asset_fee": "0.00000000000000000000",
        //             "deal_fee": "0.00000000000000000000",
        //             "deal_profit": "0.00000000000000000000",
        //             "deal_stock": "0.00000000000000000000",
        //             "effect_type": 1,
        //             "fee_asset": "",
        //             "fee_discount": "0.00000000000000000000",
        //             "last_deal_amount": "0.00000000000000000000",
        //             "last_deal_id": 0,
        //             "last_deal_price": "0.00000000000000000000",
        //             "last_deal_role": 0,
        //             "last_deal_time": 0,
        //             "last_deal_type": 0,
        //             "left": "0.0005",
        //             "leverage": "3",
        //             "maker_fee": "0.00030",
        //             "market": "BTCUSDT",
        //             "order_id": 18221659097,
        //             "position_id": 0,
        //             "position_type": 1,
        //             "price": "30000.00",
        //             "side": 2,
        //             "source": "api.v1",
        //             "stop_id": 0,
        //             "taker_fee": "0.00050",
        //             "target": 0,
        //             "type": 1,
        //             "update_time": 1651004578.618224,
        //             "user_id": 3620173
        //         },
        //         "message": "OK"
        //     }
        //
        // Stop Order
        //
        //     {"code":0,"data":{"status":"success"},"message":"OK"}
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        /**
        * @method
        * @name coinex#createOrders
        * @description create a list of trade orders (all orders should be of the same symbol)
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade002_batch_limit_orders
        * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
        * @param {object} [params] extra parameters specific to the api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        object symbol = null;
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object marketId = this.safeString(rawOrder, "symbol");
            if (isTrue(isEqual(symbol, null)))
            {
                symbol = marketId;
            } else
            {
                if (isTrue(!isEqual(symbol, marketId)))
                {
                    throw new BadRequest ((string)add(this.id, " createOrders() requires all orders to have the same symbol")) ;
                }
            }
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeValue(rawOrder, "amount");
            object price = this.safeValue(rawOrder, "price");
            object orderParams = this.safeValue(rawOrder, "params", new Dictionary<string, object>() {});
            if (isTrue(!isEqual(type, "limit")))
            {
                throw new NotSupported ((string)add(add(add(this.id, " createOrders() does not support "), type), " orders, only limit orders are accepted")) ;
            }
            object orderRequest = this.createOrderRequest(marketId, type, side, amount, price, orderParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " createOrders() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "batch_orders", this.json(ordersRequests) },
        };
        object response = await this.privatePostOrderLimitBatch(request);
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "code": 0,
        //                 "data": {
        //                     "amount": "0.0005",
        //                     "asset_fee": "0",
        //                     "avg_price": "0.00",
        //                     "client_id": "x-167673045-d34bfb41242d8fd1",
        //                     "create_time": 1701229157,
        //                     "deal_amount": "0",
        //                     "deal_fee": "0",
        //                     "deal_money": "0",
        //                     "fee_asset": null,
        //                     "fee_discount": "1",
        //                     "finished_time": null,
        //                     "id": 107745856676,
        //                     "left": "0.0005",
        //                     "maker_fee_rate": "0.002",
        //                     "market": "BTCUSDT",
        //                     "money_fee": "0",
        //                     "order_type": "limit",
        //                     "price": "23000",
        //                     "source_id": "",
        //                     "status": "not_deal",
        //                     "stock_fee": "0",
        //                     "taker_fee_rate": "0.002",
        //                     "type": "buy"
        //                 },
        //                 "message": "OK"
        //             },
        //         ],
        //         "message": "Success"
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object results = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object status = null;
            object code = this.safeInteger(entry, "code");
            if (isTrue(!isEqual(code, null)))
            {
                if (isTrue(!isEqual(code, 0)))
                {
                    status = "rejected";
                } else
                {
                    status = "open";
                }
            }
            object item = this.safeValue(entry, "data", new Dictionary<string, object>() {});
            ((IDictionary<string,object>)item)["status"] = status;
            object order = this.parseOrder(item, market);
            ((IList<object>)results).Add(order);
        }
        return results;
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#cancelOrders
        * @description cancel multiple orders
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade016_batch_cancel_order
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http021-0_cancel_order_batch
        * @param {string[]} ids order ids
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object idsString = String.Join(",", ((IList<object>)ids).ToArray());
        object response = null;
        if (isTrue(getValue(market, "spot")))
        {
            ((IDictionary<string,object>)request)["batch_ids"] = idsString;
            response = await this.privateDeleteOrderPendingBatch(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["order_ids"] = idsString;
            response = await this.perpetualPrivatePostOrderCancelBatch(this.extend(request, parameters));
        }
        //
        // spot
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "code": 0,
        //                 "data": {
        //                     "account_id": 0,
        //                     "amount": "0.0005",
        //                     "asset_fee": "0",
        //                     "avg_price": "0.00",
        //                     "client_id": "x-167673045-d4e03c38f4d19b4e",
        //                     "create_time": 1701229157,
        //                     "deal_amount": "0",
        //                     "deal_fee": "0",
        //                     "deal_money": "0",
        //                     "fee_asset": null,
        //                     "fee_discount": "1",
        //                     "finished_time": 0,
        //                     "id": 107745856682,
        //                     "left": "0",
        //                     "maker_fee_rate": "0.002",
        //                     "market": "BTCUSDT",
        //                     "money_fee": "0",
        //                     "order_type": "limit",
        //                     "price": "22000",
        //                     "status": "not_deal",
        //                     "stock_fee": "0",
        //                     "taker_fee_rate": "0.002",
        //                     "type": "buy"
        //                 },
        //                 "message": ""
        //             },
        //         ],
        //         "message": "Success"
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "code": 0,
        //                 "message": "",
        //                 "order": {
        //                     "amount": "0.0005",
        //                     "client_id": "x-167673045-b0cee0c584718b65",
        //                     "create_time": 1701233683.294231,
        //                     "deal_asset_fee": "0.00000000000000000000",
        //                     "deal_fee": "0.00000000000000000000",
        //                     "deal_profit": "0.00000000000000000000",
        //                     "deal_stock": "0.00000000000000000000",
        //                     "effect_type": 1,
        //                     "fee_asset": "",
        //                     "fee_discount": "0.00000000000000000000",
        //                     "last_deal_amount": "0.00000000000000000000",
        //                     "last_deal_id": 0,
        //                     "last_deal_price": "0.00000000000000000000",
        //                     "last_deal_role": 0,
        //                     "last_deal_time": 0,
        //                     "last_deal_type": 0,
        //                     "left": "0.0005",
        //                     "leverage": "3",
        //                     "maker_fee": "0.00030",
        //                     "market": "BTCUSDT",
        //                     "option": 0,
        //                     "order_id": 115940476323,
        //                     "position_id": 0,
        //                     "position_type": 2,
        //                     "price": "25000.00",
        //                     "side": 2,
        //                     "source": "api.v1",
        //                     "stop_id": 0,
        //                     "stop_loss_price": "0.00000000000000000000",
        //                     "stop_loss_type": 0,
        //                     "take_profit_price": "0.00000000000000000000",
        //                     "take_profit_type": 0,
        //                     "taker_fee": "0.00050",
        //                     "target": 0,
        //                     "type": 1,
        //                     "update_time": 1701233721.718884,
        //                     "user_id": 3620173
        //                 }
        //             },
        //         ],
        //         "message": "OK"
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object results = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object dataRequest = ((bool) isTrue(getValue(market, "spot"))) ? "data" : "order";
            object item = this.safeValue(entry, dataRequest, new Dictionary<string, object>() {});
            object order = this.parseOrder(item, market);
            ((IList<object>)results).Add(order);
        }
        return results;
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#editOrder
        * @description edit a trade order
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade022_modify_order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of the currency you want to trade in units of the base currency
        * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " editOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " editOrder() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "id", parseInt(id) },
        };
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["amount"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object response = await this.privatePostOrderModify(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "id": 35436205,
        //             "create_time": 1636080705,
        //             "finished_time": null,
        //             "amount": "0.30000000",
        //             "price": " 56000",
        //             "deal_amount": "0.24721428",
        //             "deal_money": "13843.9996800000000000",
        //             "deal_fee": "0",
        //             "stock_fee": "0",
        //             "money_fee": "0",
        //             " asset_fee": "8.721719798400000000000000",
        //             "fee_asset": "CET",
        //             "fee_discount": "0.70",
        //             "avg_price": "56000",
        //             "market": "BTCUSDT",
        //             "left": "0.05278572 ",
        //             "maker_fee_rate": "0.0018",
        //             "taker_fee_rate": "0.0018",
        //             "order_type": "limit",
        //             "type": "buy",
        //             "status": "cancel",
        //             "client_id ": "abcd222",
        //             "source_id": "1234"
        //     },
        //         "message": "Success"
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#cancelOrder
        * @description cancels an open order
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade018_cancle_stop_pending_order
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade015_cancel_order
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade024_cancel_order_by_client_id
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade025_cancel_stop_order_by_client_id
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http023_cancel_stop_order
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http021_cancel_order
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http042_cancel_order_by_client_id
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http043_cancel_stop_order_by_client_id
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.clientOrderId] client order id, defaults to id if not passed
        * @param {boolean} [params.stop] if stop order = true, default = false
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object stop = this.safeValue(parameters, "stop");
        object swap = getValue(market, "swap");
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object accountId = this.safeInteger(parameters, "account_id");
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("cancelOrder", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object clientOrderId = this.safeString2(parameters, "client_id", "clientOrderId");
        if (isTrue(!isEqual(marginMode, null)))
        {
            if (isTrue(isEqual(accountId, null)))
            {
                throw new BadRequest ((string)add(this.id, " cancelOrder() requires an account_id parameter for margin orders")) ;
            }
            ((IDictionary<string,object>)request)["account_id"] = accountId;
        }
        object query = this.omit(parameters, new List<object>() {"stop", "account_id", "clientOrderId"});
        object response = null;
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["client_id"] = clientOrderId;
            if (isTrue(stop))
            {
                if (isTrue(swap))
                {
                    response = await this.perpetualPrivatePostOrderCancelStopByClientId(this.extend(request, query));
                } else
                {
                    response = await this.privateDeleteOrderStopPendingByClientId(this.extend(request, query));
                }
            } else
            {
                if (isTrue(swap))
                {
                    response = await this.perpetualPrivatePostOrderCancelByClientId(this.extend(request, query));
                } else
                {
                    response = await this.privateDeleteOrderPendingByClientId(this.extend(request, query));
                }
            }
        } else
        {
            object idRequest = ((bool) isTrue(swap)) ? "order_id" : "id";
            ((IDictionary<string,object>)request)[(string)idRequest] = id;
            if (isTrue(stop))
            {
                if (isTrue(swap))
                {
                    response = await this.perpetualPrivatePostOrderCancelStop(this.extend(request, query));
                } else
                {
                    response = await this.privateDeleteOrderStopPendingId(this.extend(request, query));
                }
            } else
            {
                if (isTrue(swap))
                {
                    response = await this.perpetualPrivatePostOrderCancel(this.extend(request, query));
                } else
                {
                    response = await this.privateDeleteOrderPending(this.extend(request, query));
                }
            }
        }
        //
        // Spot and Margin
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "amount": "0.0005",
        //             "asset_fee": "0",
        //             "avg_price": "0.00",
        //             "client_id": "",
        //             "create_time": 1650951627,
        //             "deal_amount": "0",
        //             "deal_fee": "0",
        //             "deal_money": "0",
        //             "fee_asset": null,
        //             "fee_discount": "1",
        //             "finished_time": null,
        //             "id": 74510932594,
        //             "left": "0.0005",
        //             "maker_fee_rate": "0.002",
        //             "market": "BTCUSDT",
        //             "money_fee": "0",
        //             "order_type": "limit",
        //             "price": "30000",
        //             "status": "not_deal",
        //             "stock_fee": "0",
        //             "taker_fee_rate": "0.002",
        //             "type": "buy"
        //         },
        //         "message": "Success"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "amount": "0.0005",
        //             "client_id": "",
        //             "create_time": 1651004578.618224,
        //             "deal_asset_fee": "0.00000000000000000000",
        //             "deal_fee": "0.00000000000000000000",
        //             "deal_profit": "0.00000000000000000000",
        //             "deal_stock": "0.00000000000000000000",
        //             "effect_type": 1,
        //             "fee_asset": "",
        //             "fee_discount": "0.00000000000000000000",
        //             "last_deal_amount": "0.00000000000000000000",
        //             "last_deal_id": 0,
        //             "last_deal_price": "0.00000000000000000000",
        //             "last_deal_role": 0,
        //             "last_deal_time": 0,
        //             "last_deal_type": 0,
        //             "left": "0.0005",
        //             "leverage": "3",
        //             "maker_fee": "0.00030",
        //             "market": "BTCUSDT",
        //             "order_id": 18221659097,
        //             "position_id": 0,
        //             "position_type": 1,
        //             "price": "30000.00",
        //             "side": 2,
        //             "source": "api.v1",
        //             "stop_id": 0,
        //             "taker_fee": "0.00050",
        //             "target": 0,
        //             "type": 1,
        //             "update_time": 1651004578.618224,
        //             "user_id": 3620173
        //         },
        //         "message": "OK"
        //     }
        //
        // Swap Stop
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "amount": "0.0005",
        //             "client_id": "",
        //             "create_time": 1651034023.008771,
        //             "effect_type": 1,
        //             "fee_asset": "",
        //             "fee_discount": "0.00000000000000000000",
        //             "maker_fee": "0.00030",
        //             "market": "BTCUSDT",
        //             "order_id": 18256915101,
        //             "price": "31000.00",
        //             "side": 2,
        //             "source": "api.v1",
        //             "state": 1,
        //             "stop_price": "31500.00",
        //             "stop_type": 1,
        //             "taker_fee": "0.00050",
        //             "target": 0,
        //             "type": 1,
        //             "update_time": 1651034397.193624,
        //             "user_id": 3620173
        //         },
        //         "message":"OK"
        //     }
        //
        // Spot and Margin Stop
        //
        //     {"code":0,"data":{},"message":"Success"}
        //
        object data = this.safeValue(response, "data");
        return this.parseOrder(data, market);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#cancelAllOrders
        * @description cancel all open orders in a market
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade018_cancle_stop_pending_order
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade015_cancel_order
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http024_cancel_stop_all
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http022_cancel_all
        * @param {string} symbol unified market symbol of the market to cancel orders in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = getValue(market, "id");
        object accountId = this.safeInteger(parameters, "account_id", 0);
        object request = new Dictionary<string, object>() {
            { "market", marketId },
        };
        object swap = getValue(market, "swap");
        object stop = this.safeValue(parameters, "stop");
        parameters = this.omit(parameters, new List<object>() {"stop", "account_id"});
        object response = null;
        if (isTrue(swap))
        {
            if (isTrue(stop))
            {
                response = await this.perpetualPrivatePostOrderCancelStopAll(this.extend(request, parameters));
            } else
            {
                response = await this.perpetualPrivatePostOrderCancelAll(this.extend(request, parameters));
            }
        } else
        {
            ((IDictionary<string,object>)request)["account_id"] = accountId;
            if (isTrue(stop))
            {
                response = await this.privateDeleteOrderStopPending(this.extend(request, parameters));
            } else
            {
                response = await this.privateDeleteOrderPending(this.extend(request, parameters));
            }
        }
        //
        // Spot and Margin
        //
        //     {"code": 0, "data": null, "message": "Success"}
        //
        // Swap
        //
        //     {"code": 0, "data": {"status":"success"}, "message": "OK"}
        //
        return response;
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchOrder
        * @description fetches information on an order made by the user
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http028_stop_status
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http026_order_status
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade007_order_status
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object swap = getValue(market, "swap");
        object stop = this.safeValue(parameters, "stop");
        parameters = this.omit(parameters, "stop");
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object idRequest = ((bool) isTrue(swap)) ? "order_id" : "id";
        ((IDictionary<string,object>)request)[(string)idRequest] = id;
        object response = null;
        if (isTrue(swap))
        {
            if (isTrue(stop))
            {
                response = await this.perpetualPrivateGetOrderStopStatus(this.extend(request, parameters));
            } else
            {
                response = await this.perpetualPrivateGetOrderStatus(this.extend(request, parameters));
            }
        } else
        {
            response = await this.privateGetOrderStatus(this.extend(request, parameters));
        }
        //
        // Spot
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "amount": "0.1",
        //             "asset_fee": "0.22736197736197736197",
        //             "avg_price": "196.85000000000000000000",
        //             "create_time": 1537270135,
        //             "deal_amount": "0.1",
        //             "deal_fee": "0",
        //             "deal_money": "19.685",
        //             "fee_asset": "CET",
        //             "fee_discount": "0.5",
        //             "id": 1788259447,
        //             "left": "0",
        //             "maker_fee_rate": "0",
        //             "market": "ETHUSDT",
        //             "order_type": "limit",
        //             "price": "170.00000000",
        //             "status": "done",
        //             "taker_fee_rate": "0.0005",
        //             "type": "sell",
        //         },
        //         "message": "Ok"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "amount": "0.0005",
        //             "client_id": "",
        //             "create_time": 1651004578.618224,
        //             "deal_asset_fee": "0.00000000000000000000",
        //             "deal_fee": "0.00000000000000000000",
        //             "deal_profit": "0.00000000000000000000",
        //             "deal_stock": "0.00000000000000000000",
        //             "effect_type": 1,
        //             "fee_asset": "",
        //             "fee_discount": "0.00000000000000000000",
        //             "last_deal_amount": "0.00000000000000000000",
        //             "last_deal_id": 0,
        //             "last_deal_price": "0.00000000000000000000",
        //             "last_deal_role": 0,
        //             "last_deal_time": 0,
        //             "last_deal_type": 0,
        //             "left": "0.0005",
        //             "leverage": "3",
        //             "maker_fee": "0.00030",
        //             "market": "BTCUSDT",
        //             "order_id": 18221659097,
        //             "position_id": 0,
        //             "position_type": 1,
        //             "price": "30000.00",
        //             "side": 2,
        //             "source": "api.v1",
        //             "stop_id": 0,
        //             "taker_fee": "0.00050",
        //             "target": 0,
        //             "type": 1,
        //             "update_time": 1651004578.618224,
        //             "user_id": 3620173
        //         },
        //         "message": "OK"
        //     }
        //
        // Swap Stop
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "amount": "0.0005",
        //             "client_id": "",
        //             "create_time": 1651034023.008771,
        //             "effect_type": 1,
        //             "fee_asset": "",
        //             "fee_discount": "0.00000000000000000000",
        //             "maker_fee": "0.00030",
        //             "market": "BTCUSDT",
        //             "order_id": 18256915101,
        //             "price": "31000.00",
        //             "side": 2,
        //             "source": "api.v1",
        //             "state": 1,
        //             "stop_price": "31500.00",
        //             "stop_type": 1,
        //             "taker_fee": "0.00050",
        //             "target": 0,
        //             "type": 1,
        //             "update_time": 1651034397.193624,
        //             "user_id": 3620173
        //         },
        //         "message":"OK"
        //     }
        //
        object data = this.safeValue(response, "data");
        return this.parseOrder(data, market);
    }

    public async virtual Task<object> fetchOrdersByStatus(object status, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        limit = ((bool) isTrue((isEqual(limit, null)))) ? 100 : limit;
        object request = new Dictionary<string, object>() {
            { "limit", limit },
        };
        object stop = this.safeValue(parameters, "stop");
        object side = this.safeInteger(parameters, "side");
        parameters = this.omit(parameters, "stop");
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
        }
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchOrdersByStatus", market, parameters);
        var marketType = ((IList<object>) marketTypequeryVariable)[0];
        var query = ((IList<object>) marketTypequeryVariable)[1];
        object accountId = this.safeInteger(parameters, "account_id");
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOrdersByStatus", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            if (isTrue(isEqual(accountId, null)))
            {
                throw new BadRequest ((string)add(this.id, " fetchOpenOrders() and fetchClosedOrders() require an account_id parameter for margin orders")) ;
            }
            ((IDictionary<string,object>)request)["account_id"] = accountId;
        }
        parameters = this.omit(query, "account_id");
        object response = null;
        if (isTrue(isEqual(marketType, "swap")))
        {
            if (isTrue(isEqual(symbol, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchOrdersByStatus() requires a symbol argument for swap markets")) ;
            }
            if (isTrue(!isEqual(side, null)))
            {
                ((IDictionary<string,object>)request)["side"] = side;
            } else
            {
                ((IDictionary<string,object>)request)["side"] = 0;
            }
            ((IDictionary<string,object>)request)["offset"] = 0;
            if (isTrue(stop))
            {
                response = await this.perpetualPrivateGetOrderStopPending(this.extend(request, parameters));
            } else
            {
                if (isTrue(isEqual(status, "finished")))
                {
                    response = await this.perpetualPrivateGetOrderFinished(this.extend(request, parameters));
                } else if (isTrue(isEqual(status, "pending")))
                {
                    response = await this.perpetualPrivateGetOrderPending(this.extend(request, parameters));
                }
            }
        } else
        {
            ((IDictionary<string,object>)request)["page"] = 1;
            if (isTrue(isEqual(status, "finished")))
            {
                if (isTrue(stop))
                {
                    response = await this.privateGetOrderStopFinished(this.extend(request, parameters));
                } else
                {
                    response = await this.privateGetOrderFinished(this.extend(request, parameters));
                }
            } else if (isTrue(isEqual(status, "pending")))
            {
                if (isTrue(stop))
                {
                    response = await this.privateGetOrderStopPending(this.extend(request, parameters));
                } else
                {
                    response = await this.privateGetOrderPending(this.extend(request, parameters));
                }
            }
        }
        //
        // Spot and Margin
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "count": 1,
        //             "curr_page": 1,
        //             "data": [
        //                 {
        //                     "account_id": 0,
        //                     "amount": "0.0005",
        //                     "asset_fee": "0",
        //                     "avg_price": "0.00",
        //                     "client_id": "",
        //                     "create_time": 1651089247,
        //                     "deal_amount": "0",
        //                     "deal_fee": "0",
        //                     "deal_money": "0",
        //                     "fee_asset": null,
        //                     "fee_discount": "1",
        //                     "finished_time": 0,
        //                     "id": 74660190839,
        //                     "left": "0.0005",
        //                     "maker_fee_rate": "0.002",
        //                     "market": "BTCUSDT",
        //                     "money_fee": "0",
        //                     "order_type": "limit",
        //                     "price": "31000",
        //                     "status": "not_deal",
        //                     "stock_fee": "0",
        //                     "taker_fee_rate": "0.002",
        //                     "type": "buy"
        //                 }
        //             ],
        //             "has_next": false,
        //             "total": 1
        //         },
        //         "message": "Success"
        //     }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "limit": 100,
        //             "offset": 0,
        //             "records": [
        //                 {
        //                     "amount": "0.0005",
        //                     "client_id": "",
        //                     "create_time": 1651030414.088431,
        //                     "deal_asset_fee": "0",
        //                     "deal_fee": "0.00960069",
        //                     "deal_profit": "0.009825",
        //                     "deal_stock": "19.20138",
        //                     "effect_type": 0,
        //                     "fee_asset": "",
        //                     "fee_discount": "0",
        //                     "left": "0",
        //                     "leverage": "3",
        //                     "maker_fee": "0",
        //                     "market": "BTCUSDT",
        //                     "order_id": 18253447431,
        //                     "position_id": 0,
        //                     "position_type": 1,
        //                     "price": "0",
        //                     "side": 1,
        //                     "source": "web",
        //                     "stop_id": 0,
        //                     "taker_fee": "0.0005",
        //                     "target": 0,
        //                     "type": 2,
        //                     "update_time": 1651030414.08847,
        //                     "user_id": 3620173
        //                 },
        //             ]
        //         },
        //         "message": "OK"
        //     }
        //
        // Spot and Margin Stop
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "count": 1,
        //             "curr_page": 1,
        //             "data": [
        //                 {
        //                     "account_id": 0,
        //                     "amount": "155",
        //                     "client_id": "",
        //                     "create_time": 1651089182,
        //                     "fee_asset": null,
        //                     "fee_discount": "1",
        //                     "maker_fee": "0.002",
        //                     "market": "BTCUSDT",
        //                     "order_id": 74660111965,
        //                     "order_type": "market",
        //                     "price": "0",
        //                     "state": 0,
        //                     "stop_price": "31500",
        //                     "taker_fee": "0.002",
        //                     "type": "buy"
        //                 }
        //             ],
        //             "has_next": false,
        //             "total": 0
        //         },
        //         "message": "Success"
        //     }
        //
        // Swap Stop
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "limit": 100,
        //             "offset": 0,
        //             "records": [
        //                 {
        //                     "amount": "0.0005",
        //                     "client_id": "",
        //                     "create_time": 1651089147.321691,
        //                     "effect_type": 1,
        //                     "fee_asset": "",
        //                     "fee_discount": "0.00000000000000000000",
        //                     "maker_fee": "0.00030",
        //                     "market": "BTCUSDT",
        //                     "order_id": 18332143848,
        //                     "price": "31000.00",
        //                     "side": 2,
        //                     "source": "api.v1",
        //                     "state": 1,
        //                     "stop_price": "31500.00",
        //                     "stop_type": 1,
        //                     "taker_fee": "0.00050",
        //                     "target": 0,
        //                     "type": 1,
        //                     "update_time": 1651089147.321691,
        //                     "user_id": 3620173
        //                 }
        //             ],
        //             "total": 1
        //         },
        //         "message": "OK"
        //     }
        //
        object tradeRequest = ((bool) isTrue((isEqual(marketType, "swap")))) ? "records" : "data";
        object data = this.safeValue(response, "data");
        object orders = this.safeValue(data, tradeRequest, new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http027_query_pending_stop
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http025_query_pending
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade013_stop_pending_order
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade011_pending_order
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch open orders for
        * @param {int} [limit] the maximum number of  open orders structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("pending", symbol, since, limit, parameters);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http029_query_finished
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade010_stop_finished_order
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade012_finished_order
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int} [since] the earliest time in ms to fetch orders for
        * @param {int} [limit] the maximum number of order structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("finished", symbol, since, limit, parameters);
    }

    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name coinex#createDepositAddress
        * @description create a currency deposit address
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account019_update_deposit_address
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin_type", getValue(currency, "id") },
        };
        if (isTrue(inOp(parameters, "network")))
        {
            object network = this.safeString(parameters, "network");
            parameters = this.omit(parameters, "network");
            ((IDictionary<string,object>)request)["smart_contract_name"] = network;
        }
        object response = await this.privatePutBalanceDepositAddressCoinType(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "coin_address": "TV639dSpb9iGRtoFYkCp4AoaaDYKrK1pw5",
        //             "is_bitcoin_cash": false
        //         },
        //         "message": "Success"
        //     }
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseDepositAddress(data, currency);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account020_query_deposit_address
        * @param {string} code unified currency code
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin_type", getValue(currency, "id") },
        };
        object networks = this.safeValue(currency, "networks", new Dictionary<string, object>() {});
        object network = this.safeString(parameters, "network");
        parameters = this.omit(parameters, "network");
        object networksKeys = new List<object>(((IDictionary<string,object>)networks).Keys);
        object numOfNetworks = getArrayLength(networksKeys);
        if (isTrue(isTrue(!isEqual(networks, null)) && isTrue(isGreaterThan(numOfNetworks, 1))))
        {
            if (isTrue(isEqual(network, null)))
            {
                throw new ArgumentsRequired ((string)add(add(add(this.id, " fetchDepositAddress() "), code), " requires a network parameter")) ;
            }
            if (!isTrue((inOp(networks, network))))
            {
                throw new ExchangeError ((string)add(add(add(add(this.id, " fetchDepositAddress() "), network), " network not supported for "), code)) ;
            }
        }
        if (isTrue(!isEqual(network, null)))
        {
            ((IDictionary<string,object>)request)["smart_contract_name"] = network;
        }
        object response = await this.privateGetBalanceDepositAddressCoinType(this.extend(request, parameters));
        //
        //      {
        //          "code": 0,
        //          "data": {
        //            "coin_address": "1P1JqozxioQwaqPwgMAQdNDYNyaVSqgARq",
        //            // coin_address: "xxxxxxxxxxxxxx:yyyyyyyyy", // with embedded tag/memo
        //            "is_bitcoin_cash": false
        //          },
        //          "message": "Success"
        //      }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object depositAddress = this.parseDepositAddress(data, currency);
        object options = this.safeValue(this.options, "fetchDepositAddress", new Dictionary<string, object>() {});
        object fillResponseFromRequest = this.safeBool(options, "fillResponseFromRequest", true);
        if (isTrue(fillResponseFromRequest))
        {
            ((IDictionary<string,object>)depositAddress)["network"] = this.safeNetworkCode(network, currency);
        }
        return depositAddress;
    }

    public virtual object safeNetwork(object networkId, object currency = null)
    {
        object networks = this.safeValue(currency, "networks", new Dictionary<string, object>() {});
        object networksCodes = new List<object>(((IDictionary<string,object>)networks).Keys);
        object networksCodesLength = getArrayLength(networksCodes);
        if (isTrue(isTrue(isEqual(networkId, null)) && isTrue(isEqual(networksCodesLength, 1))))
        {
            return getValue(networks, getValue(networksCodes, 0));
        }
        return new Dictionary<string, object>() {
            { "id", networkId },
            { "network", ((bool) isTrue((isEqual(networkId, null)))) ? null : ((string)networkId).ToUpper() },
        };
    }

    public virtual object safeNetworkCode(object networkId, object currency = null)
    {
        object network = this.safeNetwork(networkId, currency);
        return getValue(network, "network");
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "coin_address": "1P1JqozxioQwaqPwgMAQdNDYNyaVSqgARq",
        //         "is_bitcoin_cash": false
        //     }
        //
        object coinAddress = this.safeString(depositAddress, "coin_address");
        object parts = ((string)coinAddress).Split(new [] {((string)":")}, StringSplitOptions.None).ToList<object>();
        object address = null;
        object tag = null;
        object partsLength = getArrayLength(parts);
        if (isTrue(isTrue(isGreaterThan(partsLength, 1)) && isTrue(!isEqual(getValue(parts, 0), "cfx"))))
        {
            address = getValue(parts, 0);
            tag = getValue(parts, 1);
        } else
        {
            address = coinAddress;
        }
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "address", address },
            { "tag", tag },
            { "network", null },
        };
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchMyTrades
        * @description fetch all trades made by the user
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http013_user_deals
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot003_trade014_user_deals
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch trades for
        * @param {int} [limit] the maximum number of trades structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100;
        }
        object request = new Dictionary<string, object>() {
            { "limit", limit },
            { "offset", 0 },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters);
        type = ((IList<object>)typeparametersVariable)[0];
        parameters = ((IList<object>)typeparametersVariable)[1];
        if (isTrue(isTrue(!isEqual(type, "spot")) && isTrue(isEqual(symbol, null))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument for non-spot markets")) ;
        }
        object swap = (isEqual(type, "swap"));
        object accountId = this.safeInteger(parameters, "account_id");
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchMyTrades", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            if (isTrue(isEqual(accountId, null)))
            {
                throw new BadRequest ((string)add(this.id, " fetchMyTrades() requires an account_id parameter for margin trades")) ;
            }
            ((IDictionary<string,object>)request)["account_id"] = accountId;
            parameters = this.omit(parameters, "account_id");
        }
        object response = null;
        if (isTrue(swap))
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((IDictionary<string,object>)request)["start_time"] = since;
            }
            ((IDictionary<string,object>)request)["side"] = 0;
            response = await this.perpetualPrivateGetMarketUserDeals(this.extend(request, parameters));
        } else
        {
            ((IDictionary<string,object>)request)["page"] = 1;
            response = await this.privateGetOrderUserDeals(this.extend(request, parameters));
        }
        //
        // Spot and Margin
        //
        //      {
        //          "code": 0,
        //          "data": {
        //              "data": [
        //                  {
        //                      "id": 2611520950,
        //                      "order_id": 63286573298,
        //                      "account_id": 0,
        //                      "create_time": 1638990636,
        //                      "type": "sell",
        //                      "role": "taker",
        //                      "price": "192.29",
        //                      "amount": "0.098",
        //                      "fee": "0.03768884",
        //                      "fee_asset": "USDT",
        //                      "market": "AAVEUSDT",
        //                      "deal_money": "18.84442"
        //                          },
        //                      ],
        //              "curr_page": 1,
        //              "has_next": false,
        //              "count": 3
        //              },
        //          "message": "Success"
        //      }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "limit": 100,
        //             "offset": 0,
        //             "records": [
        //                 {
        //                     "amount": "0.0012",
        //                     "deal_fee": "0.0237528",
        //                     "deal_insurance": "0",
        //                     "deal_margin": "15.8352",
        //                     "deal_order_id": 17797031903,
        //                     "deal_profit": "0",
        //                     "deal_stock": "47.5056",
        //                     "deal_type": 1,
        //                     "deal_user_id": 2969195,
        //                     "fee_asset": "",
        //                     "fee_discount": "0",
        //                     "fee_price": "0",
        //                     "fee_rate": "0.0005",
        //                     "fee_real_rate": "0.0005",
        //                     "id": 379044296,
        //                     "leverage": "3",
        //                     "margin_amount": "15.8352",
        //                     "market": "BTCUSDT",
        //                     "open_price": "39588",
        //                     "order_id": 17797092987,
        //                     "position_amount": "0.0012",
        //                     "position_id": 62052321,
        //                     "position_type": 1,
        //                     "price": "39588",
        //                     "role": 2,
        //                     "side": 2,
        //                     "time": 1650675936.016103,
        //                     "user_id": 3620173
        //                 }
        //             ]
        //         },
        //         "message": "OK"
        //     }
        //
        object tradeRequest = ((bool) isTrue(swap)) ? "records" : "data";
        object data = this.safeValue(response, "data");
        object trades = this.safeValue(data, tradeRequest, new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchPositions
        * @description fetch all open positions
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http033_pending_position
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http033-0_finished_position
        * @param {string[]} [symbols] list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.method] the method to use 'perpetualPrivateGetPositionPending' or 'perpetualPrivateGetPositionFinished' default is 'perpetualPrivateGetPositionPending'
        * @param {int} [params.side] *history endpoint only* 0: All, 1: Sell, 2: Buy, default is 0
        * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object defaultMethod = null;
        var defaultMethodparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "method", "perpetualPrivateGetPositionPending");
        defaultMethod = ((IList<object>)defaultMethodparametersVariable)[0];
        parameters = ((IList<object>)defaultMethodparametersVariable)[1];
        object isHistory = (isEqual(defaultMethod, "perpetualPrivateGetPositionFinished"));
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = null;
            if (isTrue(((symbols is IList<object>) || (symbols.GetType().IsGenericType && symbols.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                object symbolsLength = getArrayLength(symbols);
                if (isTrue(isGreaterThan(symbolsLength, 1)))
                {
                    throw new BadRequest ((string)add(this.id, " fetchPositions() symbols argument cannot contain more than 1 symbol")) ;
                }
                symbol = getValue(symbols, 0);
            } else
            {
                symbol = symbols;
            }
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
        } else
        {
            if (isTrue(isHistory))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchPositions() requires a symbol argument for closed positions")) ;
            }
        }
        if (isTrue(isHistory))
        {
            ((IDictionary<string,object>)request)["limit"] = 100;
            ((IDictionary<string,object>)request)["side"] = this.safeInteger(parameters, "side", 0); // 0: All, 1: Sell, 2: Buy
        }
        object response = null;
        if (isTrue(isEqual(defaultMethod, "perpetualPrivateGetPositionPending")))
        {
            response = await this.perpetualPrivateGetPositionPending(this.extend(request, parameters));
        } else
        {
            response = await this.perpetualPrivateGetPositionFinished(this.extend(request, parameters));
        }
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "adl_sort": 3396,
        //                 "adl_sort_val": "0.00007786",
        //                 "amount": "0.0005",
        //                 "amount_max": "0.0005",
        //                 "amount_max_margin": "6.42101333333333333333",
        //                 "bkr_price": "25684.05333333333333346175",
        //                 "bkr_price_imply": "0.00000000000000000000",
        //                 "close_left": "0.0005",
        //                 "create_time": 1651294226.110899,
        //                 "deal_all": "19.26000000000000000000",
        //                 "deal_asset_fee": "0.00000000000000000000",
        //                 "fee_asset": "",
        //                 "finish_type": 1,
        //                 "first_price": "38526.08",
        //                 "insurance": "0.00000000000000000000",
        //                 "latest_price": "38526.08",
        //                 "leverage": "3",
        //                 "liq_amount": "0.00000000000000000000",
        //                 "liq_order_price": "0",
        //                 "liq_order_time": 0,
        //                 "liq_price": "25876.68373333333333346175",
        //                 "liq_price_imply": "0.00000000000000000000",
        //                 "liq_profit": "0.00000000000000000000",
        //                 "liq_time": 0,
        //                 "mainten_margin": "0.005",
        //                 "mainten_margin_amount": "0.09631520000000000000",
        //                 "maker_fee": "0.00000000000000000000",
        //                 "margin_amount": "6.42101333333333333333",
        //                 "market": "BTCUSDT",
        //                 "open_margin": "0.33333333333333333333",
        //                 "open_margin_imply": "0.00000000000000000000",
        //                 "open_price": "38526.08000000000000000000",
        //                 "open_val": "19.26304000000000000000",
        //                 "open_val_max": "19.26304000000000000000",
        //                 "position_id": 65847227,
        //                 "profit_clearing": "-0.00963152000000000000",
        //                 "profit_real": "-0.00963152000000000000",
        //                 "profit_unreal": "0.00",
        //                 "side": 2,
        //                 "stop_loss_price": "0.00000000000000000000",
        //                 "stop_loss_type": 0,
        //                 "sys": 0,
        //                 "take_profit_price": "0.00000000000000000000",
        //                 "take_profit_type": 0,
        //                 "taker_fee": "0.00000000000000000000",
        //                 "total": 4661,
        //                 "type": 1,
        //                 "update_time": 1651294226.111196,
        //                 "user_id": 3620173
        //             },
        //         ],
        //         "message": "OK"
        //     }
        //
        object position = this.safeValue(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(position)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parsePosition(getValue(position, i), market));
        }
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchPosition
        * @description fetch data on a single open contract trade position
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http033_pending_position
        * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = await this.perpetualPrivateGetPositionPending(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "adl_sort": 3396,
        //                 "adl_sort_val": "0.00007786",
        //                 "amount": "0.0005",
        //                 "amount_max": "0.0005",
        //                 "amount_max_margin": "6.42101333333333333333",
        //                 "bkr_price": "25684.05333333333333346175",
        //                 "bkr_price_imply": "0.00000000000000000000",
        //                 "close_left": "0.0005",
        //                 "create_time": 1651294226.110899,
        //                 "deal_all": "19.26000000000000000000",
        //                 "deal_asset_fee": "0.00000000000000000000",
        //                 "fee_asset": "",
        //                 "finish_type": 1,
        //                 "first_price": "38526.08",
        //                 "insurance": "0.00000000000000000000",
        //                 "latest_price": "38526.08",
        //                 "leverage": "3",
        //                 "liq_amount": "0.00000000000000000000",
        //                 "liq_order_price": "0",
        //                 "liq_order_time": 0,
        //                 "liq_price": "25876.68373333333333346175",
        //                 "liq_price_imply": "0.00000000000000000000",
        //                 "liq_profit": "0.00000000000000000000",
        //                 "liq_time": 0,
        //                 "mainten_margin": "0.005",
        //                 "mainten_margin_amount": "0.09631520000000000000",
        //                 "maker_fee": "0.00000000000000000000",
        //                 "margin_amount": "6.42101333333333333333",
        //                 "market": "BTCUSDT",
        //                 "open_margin": "0.33333333333333333333",
        //                 "open_margin_imply": "0.00000000000000000000",
        //                 "open_price": "38526.08000000000000000000",
        //                 "open_val": "19.26304000000000000000",
        //                 "open_val_max": "19.26304000000000000000",
        //                 "position_id": 65847227,
        //                 "profit_clearing": "-0.00963152000000000000",
        //                 "profit_real": "-0.00963152000000000000",
        //                 "profit_unreal": "0.00",
        //                 "side": 2,
        //                 "stop_loss_price": "0.00000000000000000000",
        //                 "stop_loss_type": 0,
        //                 "sys": 0,
        //                 "take_profit_price": "0.00000000000000000000",
        //                 "take_profit_type": 0,
        //                 "taker_fee": "0.00000000000000000000",
        //                 "total": 4661,
        //                 "type": 1,
        //                 "update_time": 1651294226.111196,
        //                 "user_id": 3620173
        //             }
        //         ],
        //         "message": "OK"
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parsePosition(getValue(data, 0), market);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         "adl_sort": 3396,
        //         "adl_sort_val": "0.00007786",
        //         "amount": "0.0005",
        //         "amount_max": "0.0005",
        //         "amount_max_margin": "6.42101333333333333333",
        //         "bkr_price": "25684.05333333333333346175",
        //         "bkr_price_imply": "0.00000000000000000000",
        //         "close_left": "0.0005",
        //         "create_time": 1651294226.110899,
        //         "deal_all": "19.26000000000000000000",
        //         "deal_asset_fee": "0.00000000000000000000",
        //         "fee_asset": "",
        //         "finish_type": 1,
        //         "first_price": "38526.08",
        //         "insurance": "0.00000000000000000000",
        //         "latest_price": "38526.08",
        //         "leverage": "3",
        //         "liq_amount": "0.00000000000000000000",
        //         "liq_order_price": "0",
        //         "liq_order_time": 0,
        //         "liq_price": "25876.68373333333333346175",
        //         "liq_price_imply": "0.00000000000000000000",
        //         "liq_profit": "0.00000000000000000000",
        //         "liq_time": 0,
        //         "mainten_margin": "0.005",
        //         "mainten_margin_amount": "0.09631520000000000000",
        //         "maker_fee": "0.00000000000000000000",
        //         "margin_amount": "6.42101333333333333333",
        //         "market": "BTCUSDT",
        //         "open_margin": "0.33333333333333333333",
        //         "open_margin_imply": "0.00000000000000000000",
        //         "open_price": "38526.08000000000000000000",
        //         "open_val": "19.26304000000000000000",
        //         "open_val_max": "19.26304000000000000000",
        //         "position_id": 65847227,
        //         "profit_clearing": "-0.00963152000000000000",
        //         "profit_real": "-0.00963152000000000000",
        //         "profit_unreal": "0.00",
        //         "side": 2,
        //         "stop_loss_price": "0.00000000000000000000",
        //         "stop_loss_type": 0,
        //         "sys": 0,
        //         "take_profit_price": "0.00000000000000000000",
        //         "take_profit_type": 0,
        //         "taker_fee": "0.00000000000000000000",
        //         "total": 4661,
        //         "type": 1,
        //         "update_time": 1651294226.111196,
        //         "user_id": 3620173
        //     }
        //
        object marketId = this.safeString(position, "market");
        object defaultType = this.safeString(this.options, "defaultType");
        market = this.safeMarket(marketId, market, null, defaultType);
        object symbol = getValue(market, "symbol");
        object positionId = this.safeInteger(position, "position_id");
        object marginModeInteger = this.safeInteger(position, "type");
        object marginMode = ((bool) isTrue((isEqual(marginModeInteger, 1)))) ? "isolated" : "cross";
        object liquidationPrice = this.safeString(position, "liq_price");
        object entryPrice = this.safeString(position, "open_price");
        object unrealizedPnl = this.safeString(position, "profit_unreal");
        object contracts = this.safeNumber(position, "amount");
        object sideInteger = this.safeInteger(position, "side");
        object side = ((bool) isTrue((isEqual(sideInteger, 1)))) ? "short" : "long";
        object timestamp = this.safeTimestamp(position, "update_time");
        object maintenanceMargin = this.safeString(position, "mainten_margin_amount");
        object maintenanceMarginPercentage = this.safeString(position, "mainten_margin");
        object collateral = this.safeString(position, "margin_amount");
        object leverage = this.safeString(position, "leverage");
        object notional = this.safeString(position, "open_val");
        object initialMargin = Precise.stringDiv(notional, leverage);
        object initialMarginPercentage = Precise.stringDiv("1", leverage);
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", positionId },
            { "symbol", symbol },
            { "notional", this.parseNumber(notional) },
            { "marginMode", marginMode },
            { "liquidationPrice", liquidationPrice },
            { "entryPrice", this.parseNumber(entryPrice) },
            { "unrealizedPnl", this.parseNumber(unrealizedPnl) },
            { "percentage", null },
            { "contracts", contracts },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "markPrice", null },
            { "lastPrice", null },
            { "side", side },
            { "hedged", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", null },
            { "maintenanceMargin", this.parseNumber(maintenanceMargin) },
            { "maintenanceMarginPercentage", this.parseNumber(maintenanceMarginPercentage) },
            { "collateral", this.parseNumber(collateral) },
            { "initialMargin", this.parseNumber(initialMargin) },
            { "initialMarginPercentage", this.parseNumber(initialMarginPercentage) },
            { "leverage", this.parseNumber(leverage) },
            { "marginRatio", null },
            { "stopLossPrice", this.omitZero(this.safeString(position, "stop_loss_price")) },
            { "takeProfitPrice", this.omitZero(this.safeString(position, "take_profit_price")) },
        });
    }

    public async override Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#setMarginMode
        * @description set margin mode to 'cross' or 'isolated'
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http014_adjust_leverage
        * @param {string} marginMode 'cross' or 'isolated'
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        marginMode = ((string)marginMode).ToLower();
        if (isTrue(isTrue(!isEqual(marginMode, "isolated")) && isTrue(!isEqual(marginMode, "cross"))))
        {
            throw new BadRequest ((string)add(this.id, " setMarginMode() marginMode argument should be isolated or cross")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(!isEqual(getValue(market, "type"), "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " setMarginMode() supports swap contracts only")) ;
        }
        object defaultPositionType = null;
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            defaultPositionType = 1;
        } else if (isTrue(isEqual(marginMode, "cross")))
        {
            defaultPositionType = 2;
        }
        object leverage = this.safeInteger(parameters, "leverage");
        object maxLeverage = this.safeInteger(getValue(getValue(market, "limits"), "leverage"), "max", 100);
        object positionType = this.safeInteger(parameters, "position_type", defaultPositionType);
        if (isTrue(isEqual(leverage, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a leverage parameter")) ;
        }
        if (isTrue(isEqual(positionType, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a position_type parameter that will transfer margin to the specified trading pair")) ;
        }
        if (isTrue(isTrue((isLessThan(leverage, 3))) || isTrue((isGreaterThan(leverage, maxLeverage)))))
        {
            throw new BadRequest ((string)add(add(add(add(this.id, " setMarginMode() leverage should be between 3 and "), ((object)maxLeverage).ToString()), " for "), symbol)) ;
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "leverage", ((object)leverage).ToString() },
            { "position_type", positionType },
        };
        return await this.perpetualPrivatePostMarketAdjustLeverage(this.extend(request, parameters));
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#setLeverage
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http014_adjust_leverage
        * @description set the level of leverage for a market
        * @param {float} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'cross' or 'isolated' (default is 'cross')
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " setLeverage() supports swap contracts only")) ;
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("setLeverage", parameters, "cross");
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object positionType = null;
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            positionType = 1;
        } else if (isTrue(isEqual(marginMode, "cross")))
        {
            positionType = 2;
        }
        object minLeverage = this.safeInteger(getValue(getValue(market, "limits"), "leverage"), "min", 1);
        object maxLeverage = this.safeInteger(getValue(getValue(market, "limits"), "leverage"), "max", 100);
        if (isTrue(isTrue((isLessThan(leverage, minLeverage))) || isTrue((isGreaterThan(leverage, maxLeverage)))))
        {
            throw new BadRequest ((string)add(add(add(add(add(add(this.id, " setLeverage() leverage should be between "), ((object)minLeverage).ToString()), " and "), ((object)maxLeverage).ToString()), " for "), symbol)) ;
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "leverage", ((object)leverage).ToString() },
            { "position_type", positionType },
        };
        return await this.perpetualPrivatePostMarketAdjustLeverage(this.extend(request, parameters));
    }

    public async override Task<object> fetchLeverageTiers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchLeverageTiers
        * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http007_market_limit
        * @param {string[]|undefined} symbols list of unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.perpetualPublicGetMarketLimitConfig(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "BTCUSD": [
        //                 ["500001", "100", "0.005"],
        //                 ["1000001", "50", "0.01"],
        //                 ["2000001", "30", "0.015"],
        //                 ["5000001", "20", "0.02"],
        //                 ["10000001", "15", "0.025"],
        //                 ["20000001", "10", "0.03"]
        //             ],
        //             ...
        //         },
        //         "message": "OK"
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseLeverageTiers(data, symbols, null);
    }

    public override object parseLeverageTiers(object response, object symbols = null, object marketIdKey = null)
    {
        //
        //     {
        //         "BTCUSD": [
        //             ["500001", "100", "0.005"],
        //             ["1000001", "50", "0.01"],
        //             ["2000001", "30", "0.015"],
        //             ["5000001", "20", "0.02"],
        //             ["10000001", "15", "0.025"],
        //             ["20000001", "10", "0.03"]
        //         ],
        //         ...
        //     }
        //
        object tiers = new Dictionary<string, object>() {};
        object marketIds = new List<object>(((IDictionary<string,object>)response).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = getValue(marketIds, i);
            object market = this.safeMarket(marketId, null, null, "spot");
            object symbol = this.safeString(market, "symbol");
            object symbolsLength = 0;
            if (isTrue(!isEqual(symbols, null)))
            {
                symbolsLength = getArrayLength(symbols);
            }
            if (isTrue(isTrue(!isEqual(symbol, null)) && isTrue((isTrue(isEqual(symbolsLength, 0)) || isTrue(this.inArray(symbols, symbol))))))
            {
                ((IDictionary<string,object>)tiers)[(string)symbol] = this.parseMarketLeverageTiers(getValue(response, marketId), market);
            }
        }
        return tiers;
    }

    public override object parseMarketLeverageTiers(object item, object market = null)
    {
        object tiers = new List<object>() {};
        object minNotional = 0;
        for (object j = 0; isLessThan(j, getArrayLength(item)); postFixIncrement(ref j))
        {
            object bracket = getValue(item, j);
            object maxNotional = this.safeNumber(bracket, 0);
            ((IList<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", add(j, 1) },
                { "currency", ((bool) isTrue(getValue(market, "linear"))) ? getValue(market, "base") : getValue(market, "quote") },
                { "minNotional", minNotional },
                { "maxNotional", maxNotional },
                { "maintenanceMarginRate", this.safeNumber(bracket, 2) },
                { "maxLeverage", this.safeInteger(bracket, 1) },
                { "info", bracket },
            });
            minNotional = maxNotional;
        }
        return tiers;
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object addOrReduce, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "amount", this.amountToPrecision(symbol, amount) },
            { "type", addOrReduce },
        };
        object response = await this.perpetualPrivatePostPositionAdjustMargin(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "adl_sort": 1,
        //             "adl_sort_val": "0.00004320",
        //             "amount": "0.0005",
        //             "amount_max": "0.0005",
        //             "amount_max_margin": "6.57352000000000000000",
        //             "bkr_price": "16294.08000000000000011090",
        //             "bkr_price_imply": "0.00000000000000000000",
        //             "close_left": "0.0005",
        //             "create_time": 1651202571.320778,
        //             "deal_all": "19.72000000000000000000",
        //             "deal_asset_fee": "0.00000000000000000000",
        //             "fee_asset": "",
        //             "finish_type": 1,
        //             "first_price": "39441.12",
        //             "insurance": "0.00000000000000000000",
        //             "latest_price": "39441.12",
        //             "leverage": "3",
        //             "liq_amount": "0.00000000000000000000",
        //             "liq_order_price": "0",
        //             "liq_order_time": 0,
        //             "liq_price": "16491.28560000000000011090",
        //             "liq_price_imply": "0.00000000000000000000",
        //             "liq_profit": "0.00000000000000000000",
        //             "liq_time": 0,
        //             "mainten_margin": "0.005",
        //             "mainten_margin_amount": "0.09860280000000000000",
        //             "maker_fee": "0.00000000000000000000",
        //             "margin_amount": "11.57352000000000000000",
        //             "market": "BTCUSDT",
        //             "open_margin": "0.58687582908396110455",
        //             "open_margin_imply": "0.00000000000000000000",
        //             "open_price": "39441.12000000000000000000",
        //             "open_val": "19.72056000000000000000",
        //             "open_val_max": "19.72056000000000000000",
        //             "position_id": 65171206,
        //             "profit_clearing": "-0.00986028000000000000",
        //             "profit_real": "-0.00986028000000000000",
        //             "profit_unreal": "0.00",
        //             "side": 2,
        //             "stop_loss_price": "0.00000000000000000000",
        //             "stop_loss_type": 0,
        //             "sys": 0,
        //             "take_profit_price": "0.00000000000000000000",
        //             "take_profit_type": 0,
        //             "taker_fee": "0.00000000000000000000",
        //             "total": 3464,
        //             "type": 1,
        //             "update_time": 1651202638.911212,
        //             "user_id": 3620173
        //         },
        //         "message":"OK"
        //     }
        //
        object status = this.safeString(response, "message");
        object type = ((bool) isTrue((isEqual(addOrReduce, 1)))) ? "add" : "reduce";
        return this.extend(this.parseMarginModification(response, market), new Dictionary<string, object>() {
            { "amount", this.parseNumber(amount) },
            { "type", type },
            { "status", status },
        });
    }

    public virtual object parseMarginModification(object data, object market = null)
    {
        return new Dictionary<string, object>() {
            { "info", data },
            { "type", null },
            { "amount", null },
            { "code", getValue(market, "quote") },
            { "symbol", this.safeSymbol(null, market) },
            { "status", null },
        };
    }

    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name coinex#addMargin
        * @description add margin
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http032_adjust_position_margin
        * @param {string} symbol unified market symbol
        * @param {float} amount amount of margin to add
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, 1, parameters);
    }

    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name coinex#reduceMargin
        * @description remove margin from a position
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http032_adjust_position_margin
        * @param {string} symbol unified market symbol
        * @param {float} amount the amount of margin to remove
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, 2, parameters);
    }

    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchFundingHistory
        * @description fetch the history of funding payments paid and received on this account
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http034_funding_position
        * @param {string} symbol unified market symbol
        * @param {int} [since] the earliest time in ms to fetch funding history for
        * @param {int} [limit] the maximum number of funding history structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingHistory() requires a symbol argument")) ;
        }
        limit = ((bool) isTrue((isEqual(limit, null)))) ? 100 : limit;
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "limit", limit },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        object response = await this.perpetualPrivateGetPositionFunding(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "limit": 100,
        //             "offset": 0,
        //             "records": [
        //                 {
        //                     "amount": "0.0012",
        //                     "asset": "USDT",
        //                     "funding": "-0.0095688273996",
        //                     "funding_rate": "0.00020034",
        //                     "market": "BTCUSDT",
        //                     "position_id": 62052321,
        //                     "price": "39802.45",
        //                     "real_funding_rate": "0.00020034",
        //                     "side": 2,
        //                     "time": 1650729623.933885,
        //                     "type": 1,
        //                     "user_id": 3620173,
        //                     "value": "47.76294"
        //                 },
        //             ]
        //         },
        //         "message": "OK"
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object resultList = this.safeValue(data, "records", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(resultList)); postFixIncrement(ref i))
        {
            object entry = getValue(resultList, i);
            object timestamp = this.safeTimestamp(entry, "time");
            object currencyId = this.safeString(entry, "asset");
            object code = this.safeCurrencyCode(currencyId);
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbol },
                { "code", code },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
                { "id", this.safeNumber(entry, "position_id") },
                { "amount", this.safeNumber(entry, "funding") },
            });
        }
        return result;
    }

    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchFundingRate
        * @description fetch the current funding rate
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http008_market_ticker
        * @param {string} symbol unified market symbol
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRate() supports swap contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = await this.perpetualPublicGetMarketTicker(this.extend(request, parameters));
        //
        //     {
        //          "code": 0,
        //         "data":
        //         {
        //             "date": 1650678472474,
        //             "ticker": {
        //                 "vol": "6090.9430",
        //                 "low": "39180.30",
        //                 "open": "40474.97",
        //                 "high": "40798.01",
        //                 "last": "39659.30",
        //                 "buy": "39663.79",
        //                 "period": 86400,
        //                 "funding_time": 372,
        //                 "position_amount": "270.1956",
        //                 "funding_rate_last": "0.00022913",
        //                 "funding_rate_next": "0.00013158",
        //                 "funding_rate_predict": "0.00016552",
        //                 "insurance": "16045554.83969682659674035672",
        //                 "sign_price": "39652.48",
        //                 "index_price": "39648.44250000",
        //                 "sell_total": "22.3913",
        //                 "buy_total": "19.4498",
        //                 "buy_amount": "12.8942",
        //                 "sell": "39663.80",
        //                 "sell_amount": "0.9388"
        //             }
        //         },
        //         "message": "OK"
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object ticker = this.safeValue(data, "ticker", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(data, "date");
        ((IDictionary<string,object>)ticker)["timestamp"] = timestamp; // avoid changing parseFundingRate signature
        return this.parseFundingRate(ticker, market);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        // fetchFundingRate
        //
        //     {
        //         "vol": "6090.9430",
        //         "low": "39180.30",
        //         "open": "40474.97",
        //         "high": "40798.01",
        //         "last": "39659.30",
        //         "buy": "39663.79",
        //         "period": 86400,
        //         "funding_time": 372,
        //         "position_amount": "270.1956",
        //         "funding_rate_last": "0.00022913",
        //         "funding_rate_next": "0.00013158",
        //         "funding_rate_predict": "0.00016552",
        //         "insurance": "16045554.83969682659674035672",
        //         "sign_price": "39652.48",
        //         "index_price": "39648.44250000",
        //         "sell_total": "22.3913",
        //         "buy_total": "19.4498",
        //         "buy_amount": "12.8942",
        //         "sell": "39663.80",
        //         "sell_amount": "0.9388"
        //     }
        //
        object timestamp = this.safeInteger(contract, "timestamp");
        contract = this.omit(contract, "timestamp");
        object fundingDelta = multiply(multiply(this.safeInteger(contract, "funding_time"), 60), 1000);
        object fundingHour = divide((add(timestamp, fundingDelta)), 3600000);
        object fundingTimestamp = multiply(Math.Round(Convert.ToDouble(fundingHour)), 3600000);
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", this.safeSymbol(null, market) },
            { "markPrice", this.safeNumber(contract, "sign_price") },
            { "indexPrice", this.safeNumber(contract, "index_price") },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fundingRate", this.safeNumber(contract, "funding_rate_next") },
            { "fundingTimestamp", fundingTimestamp },
            { "fundingDatetime", this.iso8601(fundingTimestamp) },
            { "nextFundingRate", this.safeNumber(contract, "funding_rate_predict") },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", this.safeNumber(contract, "funding_rate_last") },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        /**
        *  @method
        * @name coinex#fetchFundingRates
        * @description fetch the current funding rates
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http009_market_ticker_all
        * @param {string[]} symbols unified market symbols
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} an array of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = this.safeValue(symbols, 0);
            market = this.market(symbol);
            if (!isTrue(getValue(market, "swap")))
            {
                throw new BadSymbol ((string)add(this.id, " fetchFundingRates() supports swap contracts only")) ;
            }
        }
        object response = await this.perpetualPublicGetMarketTickerAll(parameters);
        //
        //     {
        //         "code": 0,
        //         "data":
        //         {
        //             "date": 1650678472474,
        //             "ticker": {
        //                 "BTCUSDT": {
        //                     "vol": "6090.9430",
        //                     "low": "39180.30",
        //                     "open": "40474.97",
        //                     "high": "40798.01",
        //                     "last": "39659.30",
        //                     "buy": "39663.79",
        //                     "period": 86400,
        //                     "funding_time": 372,
        //                     "position_amount": "270.1956",
        //                     "funding_rate_last": "0.00022913",
        //                     "funding_rate_next": "0.00013158",
        //                     "funding_rate_predict": "0.00016552",
        //                     "insurance": "16045554.83969682659674035672",
        //                     "sign_price": "39652.48",
        //                     "index_price": "39648.44250000",
        //                     "sell_total": "22.3913",
        //                     "buy_total": "19.4498",
        //                     "buy_amount": "12.8942",
        //                     "sell": "39663.80",
        //                     "sell_amount": "0.9388"
        //                 }
        //             }
        //         },
        //         "message": "OK"
        //     }
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object tickers = this.safeValue(data, "ticker", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(data, "date");
        object result = new List<object>() {};
        object marketIds = new List<object>(((IDictionary<string,object>)tickers).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
        {
            object marketId = getValue(marketIds, i);
            if (isTrue(isEqual(getIndexOf(marketId, "_"), -1)))
            {
                object marketInner = this.safeMarket(marketId, null, null, "swap");
                object ticker = getValue(tickers, marketId);
                ((IDictionary<string,object>)ticker)["timestamp"] = timestamp;
                ((IList<object>)result).Add(this.parseFundingRate(ticker, marketInner));
            }
        }
        return this.filterByArray(result, "symbol", symbols);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#withdraw
        * @description make a withdrawal
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account015_submit_withdraw
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string} tag
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.network] unified network code
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object networkCode = this.safeStringUpper(parameters, "network");
        parameters = this.omit(parameters, "network");
        if (isTrue(tag))
        {
            address = add(add(address, ":"), tag);
        }
        object request = new Dictionary<string, object>() {
            { "coin_type", getValue(currency, "id") },
            { "coin_address", address },
            { "actual_amount", parseFloat(this.numberToString(amount)) },
            { "transfer_method", "onchain" },
        };
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["smart_contract_name"] = this.networkCodeToId(networkCode);
        }
        object response = await this.privatePostBalanceCoinWithdraw(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "actual_amount": "1.00000000",
        //             "amount": "1.00000000",
        //             "coin_address": "1KAv3pazbTk2JnQ5xTo6fpKK7p1it2RzD4",
        //             "coin_type": "BCH",
        //             "coin_withdraw_id": 206,
        //             "confirmations": 0,
        //             "create_time": 1524228297,
        //             "status": "audit",
        //             "tx_fee": "0",
        //             "tx_id": ""
        //         },
        //         "message": "Ok"
        //     }
        //
        object transaction = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseTransaction(transaction, currency);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "audit", "pending" },
            { "pass", "pending" },
            { "processing", "pending" },
            { "confirming", "pending" },
            { "not_pass", "failed" },
            { "cancel", "canceled" },
            { "finish", "ok" },
            { "fail", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchFundingRateHistory
        * @see https://viabtc.github.io/coinex_api_en_doc/futures/#docsfutures001_http038_funding_history
        * @description fetches historical funding rate prices
        * @param {string} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
        * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
        * @param {int} [params.until] timestamp in ms of the latest funding rate
        * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object paginate = false;
        var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "paginate");
        paginate = ((IList<object>)paginateparametersVariable)[0];
        parameters = ((IList<object>)paginateparametersVariable)[1];
        if (isTrue(paginate))
        {
            return await this.fetchPaginatedCallDeterministic("fetchFundingRateHistory", symbol, since, limit, "8h", parameters, 1000);
        }
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "limit", limit },
            { "offset", 0 },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        var requestparametersVariable = this.handleUntilOption("end_time", request, parameters);
        request = ((IList<object>)requestparametersVariable)[0];
        parameters = ((IList<object>)requestparametersVariable)[1];
        object response = await this.perpetualPublicGetMarketFundingHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "offset": 0,
        //             "limit": 3,
        //             "records": [
        //                 {
        //                     "time": 1650672021.6230309,
        //                     "market": "BTCUSDT",
        //                     "asset": "USDT",
        //                     "funding_rate": "0.00022913",
        //                     "funding_rate_real": "0.00022913"
        //                 },
        //             ]
        //         },
        //         "message": "OK"
        //     }
        //
        object data = this.safeValue(response, "data");
        object result = this.safeValue(data, "records", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
        {
            object entry = getValue(result, i);
            object marketId = this.safeString(entry, "market");
            object symbolInner = this.safeSymbol(marketId, market, null, "swap");
            object timestamp = this.safeTimestamp(entry, "time");
            ((IList<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbolInner },
                { "fundingRate", this.safeNumber(entry, "funding_rate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //    {
        //        "coin_deposit_id": 32555985,
        //        "create_time": 1673325495,
        //        "amount": "12.71",
        //        "amount_display": "12.71",
        //        "diff_amount": "0",
        //        "min_amount": "0",
        //        "actual_amount": "12.71",
        //        "actual_amount_display": "12.71",
        //        "confirmations": 35,
        //        "tx_id": "0x57f1c92cc10b48316e2bf5faf230694fec2174e7744c1562a9a88b9c1e585f56",
        //        "tx_id_display": "0x57f1c92cc10b48316e2bf5faf230694fec2174e7744c1562a9a88b9c1e585f56",
        //        "coin_address": "0xe7a3831c56836f466b6a6268cff4fc852cf4b738",
        //        "coin_address_display": "0xe7a3****f4b738",
        //        "add_explorer": "https://bscscan.com/address/0xe7a3831c56836f466b6a6268cff4fc852cf4b738",
        //        "coin_type": "USDT",
        //        "smart_contract_name": "BSC",
        //        "transfer_method": "onchain",
        //        "status": "finish",
        //        "status_display": "finish",
        //        "remark": "",
        //        "explorer": "https://bscscan.com/tx/0x57f1c92cc10b48316e2bf5faf230694fec2174e7744c1562a9a88b9c1e585f56"
        //    }
        //
        // fetchWithdrawals
        //
        //    {
        //        "coin_withdraw_id": 20076836,
        //        "create_time": 1673325776,
        //        "actual_amount": "0.029",
        //        "actual_amount_display": "0.029",
        //        "amount": "0.03",
        //        "amount_display": "0.03",
        //        "coin_address": "MBhJcc3r5b3insc7QxyvEPtf31NqUdJpAb",
        //        "app_coin_address_display": "MBh****pAb",
        //        "coin_address_display": "MBhJcc****UdJpAb",
        //        "add_explorer": "https://explorer.viawallet.com/ltc/address/MBhJcc3r5b3insc7QxyvEPtf31NqUdJpAb",
        //        "coin_type": "LTC",
        //        "confirmations": 7,
        //        "explorer": "https://explorer.viawallet.com/ltc/tx/a0aa082132619b8a499b87e7d5bc3c508e0227104f5202ae26b695bb4cb7fbf9",
        //        "fee": "0",
        //        "remark": "",
        //        "smart_contract_name": "",
        //        "status": "finish",
        //        "status_display": "finish",
        //        "transfer_method": "onchain",
        //        "tx_fee": "0.001",
        //        "tx_id": "a0aa082132619b8a499b87e7d5bc3c508e0227104f5202ae26b695bb4cb7fbf9"
        //    }
        //
        object id = this.safeString2(transaction, "coin_withdraw_id", "coin_deposit_id");
        object address = this.safeString(transaction, "coin_address");
        object tag = this.safeString(transaction, "remark"); // set but unused
        if (isTrue(!isEqual(tag, null)))
        {
            if (isTrue(isLessThan(((string)tag).Length, 1)))
            {
                tag = null;
            }
        }
        object txid = this.safeValue(transaction, "tx_id");
        if (isTrue(!isEqual(txid, null)))
        {
            if (isTrue(isLessThan(getArrayLength(txid), 1)))
            {
                txid = null;
            }
        }
        object currencyId = this.safeString(transaction, "coin_type");
        object code = this.safeCurrencyCode(currencyId, currency);
        object timestamp = this.safeTimestamp(transaction, "create_time");
        object type = ((bool) isTrue((inOp(transaction, "coin_withdraw_id")))) ? "withdrawal" : "deposit";
        object status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        object networkId = this.safeString(transaction, "smart_contract_name");
        object amount = this.safeNumber(transaction, "actual_amount");
        object feeCost = this.safeString(transaction, "tx_fee");
        object transferMethod = this.safeString(transaction, "transfer_method");
        object intern = isEqual(transferMethod, "local");
        object addressTo = null;
        object addressFrom = null;
        if (isTrue(isEqual(type, "deposit")))
        {
            feeCost = "0";
            addressTo = address;
        } else
        {
            addressFrom = address;
        }
        object fee = new Dictionary<string, object>() {
            { "cost", this.parseNumber(feeCost) },
            { "currency", code },
        };
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", this.networkIdToCode(networkId) },
            { "address", address },
            { "addressTo", null },
            { "addressFrom", null },
            { "tag", tag },
            { "tagTo", addressTo },
            { "tagFrom", addressFrom },
            { "type", type },
            { "amount", this.parseNumber(amount) },
            { "currency", code },
            { "status", status },
            { "updated", null },
            { "fee", fee },
            { "comment", null },
            { "internal", intern },
        };
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name coinex#transfer
        * @description transfer currency internally between wallets on the same account
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account014_balance_contract_transfer
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account013_margin_transfer
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object amountToPrecision = this.currencyToPrecision(code, amount);
        object request = new Dictionary<string, object>() {
            { "amount", amountToPrecision },
            { "coin_type", getValue(currency, "id") },
        };
        object response = null;
        if (isTrue(isTrue((isEqual(fromAccount, "spot"))) && isTrue((isEqual(toAccount, "swap")))))
        {
            ((IDictionary<string,object>)request)["transfer_side"] = "in"; // 'in' spot to swap, 'out' swap to spot
            response = await this.privatePostContractBalanceTransfer(this.extend(request, parameters));
        } else if (isTrue(isTrue((isEqual(fromAccount, "swap"))) && isTrue((isEqual(toAccount, "spot")))))
        {
            ((IDictionary<string,object>)request)["transfer_side"] = "out"; // 'in' spot to swap, 'out' swap to spot
            response = await this.privatePostContractBalanceTransfer(this.extend(request, parameters));
        } else
        {
            object accountsById = this.safeValue(this.options, "accountsById", new Dictionary<string, object>() {});
            object fromId = this.safeString(accountsById, fromAccount, fromAccount);
            object toId = this.safeString(accountsById, toAccount, toAccount);
            // fromAccount and toAccount must be integers for margin transfers
            // spot is 0, use fetchBalance() to find the margin account id
            ((IDictionary<string,object>)request)["from_account"] = parseInt(fromId);
            ((IDictionary<string,object>)request)["to_account"] = parseInt(toId);
            response = await this.privatePostMarginTransfer(this.extend(request, parameters));
        }
        //
        //     {"code": 0, "data": null, "message": "Success"}
        //
        return this.extend(this.parseTransfer(response, currency), new Dictionary<string, object>() {
            { "amount", this.parseNumber(amountToPrecision) },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
        });
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "0", "ok" },
            { "SUCCESS", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // fetchTransfers Swap
        //
        //     {
        //         "amount": "10",
        //         "asset": "USDT",
        //         "transfer_type": "transfer_out", // from swap to spot
        //         "created_at": 1651633422
        //     },
        //
        // fetchTransfers Margin
        //
        //     {
        //         "id": 7580062,
        //         "updated_at": 1653684379,
        //         "user_id": 3620173,
        //         "from_account_id": 0,
        //         "to_account_id": 1,
        //         "asset": "BTC",
        //         "amount": "0.00160829",
        //         "balance": "0.00160829",
        //         "transfer_type": "IN",
        //         "status": "SUCCESS",
        //         "created_at": 1653684379
        //     },
        //
        object timestamp = this.safeTimestamp(transfer, "created_at");
        object transferType = this.safeString(transfer, "transfer_type");
        object fromAccount = null;
        object toAccount = null;
        if (isTrue(isEqual(transferType, "transfer_out")))
        {
            fromAccount = "swap";
            toAccount = "spot";
        } else if (isTrue(isEqual(transferType, "transfer_in")))
        {
            fromAccount = "spot";
            toAccount = "swap";
        } else if (isTrue(isEqual(transferType, "IN")))
        {
            fromAccount = "spot";
            toAccount = "margin";
        } else if (isTrue(isEqual(transferType, "OUT")))
        {
            fromAccount = "margin";
            toAccount = "spot";
        }
        object currencyId = this.safeString(transfer, "asset");
        object currencyCode = this.safeCurrencyCode(currencyId, currency);
        return new Dictionary<string, object>() {
            { "id", this.safeInteger(transfer, "id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", currencyCode },
            { "amount", this.safeNumber(transfer, "amount") },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "status", this.parseTransferStatus(this.safeString2(transfer, "code", "status")) },
        };
    }

    public async virtual Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchTransfers
        * @description fetch a history of internal transfers made on an account
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account025_margin_transfer_history
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account024_contract_transfer_history
        * @param {string} code unified currency code of the currency transferred
        * @param {int} [since] the earliest time in ms to fetch transfers for
        * @param {int} [limit] the maximum number of  transfers structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        object request = new Dictionary<string, object>() {
            { "page", 1 },
        };
        object page = this.safeInteger(parameters, "page");
        if (isTrue(!isEqual(page, null)))
        {
            ((IDictionary<string,object>)request)["page"] = page;
        }
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["asset"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        } else
        {
            ((IDictionary<string,object>)request)["limit"] = 100;
        }
        parameters = this.omit(parameters, "page");
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchTransfers", parameters);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        object response = null;
        if (isTrue(!isEqual(marginMode, null)))
        {
            response = await this.privateGetMarginTransferHistory(this.extend(request, parameters));
        } else
        {
            response = await this.privateGetContractTransferHistory(this.extend(request, parameters));
        }
        //
        // Swap
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "records": [
        //                 {
        //                     "amount": "10",
        //                     "asset": "USDT",
        //                     "transfer_type": "transfer_out",
        //                     "created_at": 1651633422
        //                 },
        //             ],
        //             "total": 5
        //         },
        //         "message": "Success"
        //     }
        //
        // Margin
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "records": [
        //                 {
        //                     "id": 7580062,
        //                     "updated_at": 1653684379,
        //                     "user_id": 3620173,
        //                     "from_account_id": 0,
        //                     "to_account_id": 1,
        //                     "asset": "BTC",
        //                     "amount": "0.00160829",
        //                     "balance": "0.00160829",
        //                     "transfer_type": "IN",
        //                     "status": "SUCCESS",
        //                     "created_at": 1653684379
        //                 }
        //             ],
        //             "total": 1
        //         },
        //         "message": "Success"
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object transfers = this.safeValue(data, "records", new List<object>() {});
        return this.parseTransfers(transfers, currency, since, limit);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account026_withdraw_list
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch withdrawals for
        * @param {int} [limit] the maximum number of withdrawals structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            await this.loadMarkets();
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin_type"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["Limit"] = limit;
        }
        object response = await this.privateGetBalanceCoinWithdraw(this.extend(request, parameters));
        //
        //    {
        //        "code": 0,
        //        "data": {
        //            "has_next": false,
        //            "curr_page": 1,
        //            "count": 1,
        //            "data": [
        //                {
        //                    "coin_withdraw_id": 20076836,
        //                    "create_time": 1673325776,
        //                    "actual_amount": "0.029",
        //                    "actual_amount_display": "0.029",
        //                    "amount": "0.03",
        //                    "amount_display": "0.03",
        //                    "coin_address": "MBhJcc3r5b3insc7QxyvEPtf31NqUdJpAb",
        //                    "app_coin_address_display": "MBh****pAb",
        //                    "coin_address_display": "MBhJcc****UdJpAb",
        //                    "add_explorer": "https://explorer.viawallet.com/ltc/address/MBhJcc3r5b3insc7QxyvEPtf31NqUdJpAb",
        //                    "coin_type": "LTC",
        //                    "confirmations": 7,
        //                    "explorer": "https://explorer.viawallet.com/ltc/tx/a0aa082132619b8a499b87e7d5bc3c508e0227104f5202ae26b695bb4cb7fbf9",
        //                    "fee": "0",
        //                    "remark": "",
        //                    "smart_contract_name": "",
        //                    "status": "finish",
        //                    "status_display": "finish",
        //                    "transfer_method": "onchain",
        //                    "tx_fee": "0.001",
        //                    "tx_id": "a0aa082132619b8a499b87e7d5bc3c508e0227104f5202ae26b695bb4cb7fbf9"
        //                }
        //            ],
        //            "total": 1,
        //            "total_page": 1
        //        },
        //        "message": "Success"
        //    }
        //
        object data = this.safeValue(response, "data");
        if (!isTrue(((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            data = this.safeValue(data, "data", new List<object>() {});
        }
        return this.parseTransactions(data, currency, since, limit);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account009_deposit_list
        * @param {string} code unified currency code
        * @param {int} [since] the earliest time in ms to fetch deposits for
        * @param {int} [limit] the maximum number of deposits structures to retrieve
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            await this.loadMarkets();
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["coin_type"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["Limit"] = limit;
        }
        object response = await this.privateGetBalanceCoinDeposit(this.extend(request, parameters));
        //
        //    {
        //        "code": 0,
        //        "data": {
        //            "has_next": false,
        //            "curr_page": 1,
        //            "count": 1,
        //            "data": [
        //                {
        //                    "coin_deposit_id": 32555985,
        //                    "create_time": 1673325495,
        //                    "amount": "12.71",
        //                    "amount_display": "12.71",
        //                    "diff_amount": "0",
        //                    "min_amount": "0",
        //                    "actual_amount": "12.71",
        //                    "actual_amount_display": "12.71",
        //                    "confirmations": 35,
        //                    "tx_id": "0x57f1c92cc10b48316e2bf5faf230694fec2174e7744c1562a9a88b9c1e585f56",
        //                    "tx_id_display": "0x57f1c92cc10b48316e2bf5faf230694fec2174e7744c1562a9a88b9c1e585f56",
        //                    "coin_address": "0xe7a3831c56836f466b6a6268cff4fc852cf4b738",
        //                    "coin_address_display": "0xe7a3****f4b738",
        //                    "add_explorer": "https://bscscan.com/address/0xe7a3831c56836f466b6a6268cff4fc852cf4b738",
        //                    "coin_type": "USDT",
        //                    "smart_contract_name": "BSC",
        //                    "transfer_method": "onchain",
        //                    "status": "finish",
        //                    "status_display": "finish",
        //                    "remark": "",
        //                    "explorer": "https://bscscan.com/tx/0x57f1c92cc10b48316e2bf5faf230694fec2174e7744c1562a9a88b9c1e585f56"
        //                }
        //            ],
        //            "total": 1,
        //            "total_page": 1
        //        },
        //        "message": "Success"
        //    }
        //
        object data = this.safeValue(response, "data");
        if (!isTrue(((data is IList<object>) || (data.GetType().IsGenericType && data.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
        {
            data = this.safeValue(data, "data", new List<object>() {});
        }
        return this.parseTransactions(data, currency, since, limit);
    }

    public virtual object parseIsolatedBorrowRate(object info, object market = null)
    {
        //
        //     {
        //         "market": "BTCUSDT",
        //         "leverage": 10,
        //         "BTC": {
        //             "min_amount": "0.002",
        //             "max_amount": "200",
        //             "day_rate": "0.001"
        //         },
        //         "USDT": {
        //             "min_amount": "60",
        //             "max_amount": "5000000",
        //             "day_rate": "0.001"
        //         }
        //     },
        //
        object marketId = this.safeString(info, "market");
        market = this.safeMarket(marketId, market, null, "spot");
        object baseInfo = this.safeValue(info, getValue(market, "baseId"));
        object quoteInfo = this.safeValue(info, getValue(market, "quoteId"));
        return new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "base", getValue(market, "base") },
            { "baseRate", this.safeNumber(baseInfo, "day_rate") },
            { "quote", getValue(market, "quote") },
            { "quoteRate", this.safeNumber(quoteInfo, "day_rate") },
            { "period", 86400000 },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    public async override Task<object> fetchIsolatedBorrowRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchIsolatedBorrowRate
        * @description fetch the rate of interest to borrow a currency for margin trading
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account007_margin_account_settings
        * @param {string} symbol unified symbol of the market to fetch the borrow rate for
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} an [isolated borrow rate structure]{@link https://docs.ccxt.com/#/?id=isolated-borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = await this.privateGetMarginConfig(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "market": "BTCUSDT",
        //             "leverage": 10,
        //             "BTC": {
        //                 "min_amount": "0.002",
        //                 "max_amount": "200",
        //                 "day_rate": "0.001"
        //             },
        //             "USDT": {
        //                 "min_amount": "60",
        //                 "max_amount": "5000000",
        //                 "day_rate": "0.001"
        //             }
        //         },
        //         "message": "Success"
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseIsolatedBorrowRate(data, market);
    }

    public async override Task<object> fetchIsolatedBorrowRates(object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchIsolatedBorrowRates
        * @description fetch the borrow interest rates of all currencies
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot002_account007_margin_account_settings
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a list of [isolated borrow rate structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#isolated-borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetMarginConfig(parameters);
        //
        //     {
        //         "code": 0,
        //         "data": [
        //             {
        //                 "market": "BTCUSDT",
        //                 "leverage": 10,
        //                 "BTC": {
        //                     "min_amount": "0.002",
        //                     "max_amount": "200",
        //                     "day_rate": "0.001"
        //                 },
        //                 "USDT": {
        //                     "min_amount": "60",
        //                     "max_amount": "5000000",
        //                     "day_rate": "0.001"
        //                 }
        //             },
        //         ],
        //         "message": "Success"
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            ((IList<object>)rates).Add(this.parseIsolatedBorrowRate(getValue(data, i)));
        }
        return rates;
    }

    public async override Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["market"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object response = await this.privateGetMarginLoanHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "page": 1,
        //             "limit": 10,
        //             "total": 1,
        //             "has_next": false,
        //             "curr_page": 1,
        //             "count": 1,
        //             "data": [
        //                 {
        //                     "loan_id": 2616357,
        //                     "create_time": 1654214027,
        //                     "market_type": "BTCUSDT",
        //                     "coin_type": "BTC",
        //                     "day_rate": "0.001",
        //                     "loan_amount": "0.0144",
        //                     "interest_amount": "0",
        //                     "unflat_amount": "0",
        //                     "expire_time": 1655078027,
        //                     "is_renew": true,
        //                     "status": "finish"
        //                 }
        //             ],
        //             "total_page": 1
        //         },
        //         "message": "Success"
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeValue(data, "data", new List<object>() {});
        object interest = this.parseBorrowInterests(rows, market);
        return this.filterByCurrencySinceLimit(interest, code, since, limit);
    }

    public override object parseBorrowInterest(object info, object market = null)
    {
        //
        //     {
        //         "loan_id": 2616357,
        //         "create_time": 1654214027,
        //         "market_type": "BTCUSDT",
        //         "coin_type": "BTC",
        //         "day_rate": "0.001",
        //         "loan_amount": "0.0144",
        //         "interest_amount": "0",
        //         "unflat_amount": "0",
        //         "expire_time": 1655078027,
        //         "is_renew": true,
        //         "status": "finish"
        //     }
        //
        object marketId = this.safeString(info, "market_type");
        market = this.safeMarket(marketId, market, null, "spot");
        object symbol = this.safeString(market, "symbol");
        object timestamp = this.safeTimestamp(info, "expire_time");
        object unflatAmount = this.safeString(info, "unflat_amount");
        object loanAmount = this.safeString(info, "loan_amount");
        object interest = Precise.stringSub(unflatAmount, loanAmount);
        if (isTrue(isEqual(unflatAmount, "0")))
        {
            interest = null;
        }
        return new Dictionary<string, object>() {
            { "account", null },
            { "symbol", symbol },
            { "marginMode", "isolated" },
            { "marginType", null },
            { "currency", this.safeCurrencyCode(this.safeString(info, "coin_type")) },
            { "interest", this.parseNumber(interest) },
            { "interestRate", this.safeNumber(info, "day_rate") },
            { "amountBorrowed", this.parseNumber(loanAmount) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async override Task<object> borrowIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name coinex#borrowIsolatedMargin
        * @description create a loan to borrow margin
        * @see https://github.com/coinexcom/coinex_exchange_api/wiki/086margin_loan
        * @param {string} symbol unified market symbol, required for coinex
        * @param {string} code unified currency code of the currency to borrow
        * @param {float} amount the amount to borrow
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "coin_type", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.privatePostMarginLoan(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "loan_id": 1670
        //         },
        //         "message": "Success"
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object transaction = this.parseMarginLoan(data, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    public async override Task<object> repayIsolatedMargin(object symbol, object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name coinex#repayIsolatedMargin
        * @description repay borrowed margin and interest
        * @see https://github.com/coinexcom/coinex_exchange_api/wiki/087margin_flat
        * @param {string} symbol unified market symbol, required for coinex
        * @param {string} code unified currency code of the currency to repay
        * @param {float} amount the amount to repay
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {string} [params.loan_id] extra parameter that is not required
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "coin_type", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.privatePostMarginFlat(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "data": null,
        //         "message": "Success"
        //     }
        //
        object transaction = this.parseMarginLoan(response, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        // borrowMargin
        //
        //     {
        //         "loan_id": 1670
        //     }
        //
        // repayMargin
        //
        //     {
        //         "code": 0,
        //         "data": null,
        //         "message": "Success"
        //     }
        //
        return new Dictionary<string, object>() {
            { "id", this.safeInteger(info, "loan_id") },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "amount", null },
            { "symbol", null },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name coinex#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://viabtc.github.io/coinex_api_en_doc/spot/#docsspot001_market010_asset_config
        * @param {string[]|undefined} codes list of unified currency codes
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object[]} a list of [fees structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(codes, null)))
        {
            object codesLength = getArrayLength(codes);
            if (isTrue(isEqual(codesLength, 1)))
            {
                ((IDictionary<string,object>)request)["coin_type"] = this.safeValue(codes, 0);
            }
        }
        object response = await this.publicGetCommonAssetConfig(this.extend(request, parameters));
        //
        //    {
        //        "code": 0,
        //        "data": {
        //            "CET-CSC": {
        //                "asset": "CET",
        //                "chain": "CSC",
        //                "can_deposit": true,
        //                "can_withdraw ": false,
        //                "deposit_least_amount": "1",
        //                "withdraw_least_amount": "1",
        //                "withdraw_tx_fee": "0.1"
        //            },
        //            "CET-ERC20": {
        //                "asset": "CET",
        //                "chain": "ERC20",
        //                "can_deposit": true,
        //                "can_withdraw": false,
        //                "deposit_least_amount": "14",
        //                "withdraw_least_amount": "14",
        //                "withdraw_tx_fee": "14"
        //            }
        //        },
        //        "message": "Success"
        //    }
        //
        return this.parseDepositWithdrawFees(response, codes);
    }

    public override object parseDepositWithdrawFees(object response, object codes = null, object currencyIdKey = null)
    {
        object depositWithdrawFees = new Dictionary<string, object>() {};
        codes = this.marketCodes(codes);
        object data = this.safeValue(response, "data");
        object currencyIds = new List<object>(((IDictionary<string,object>)data).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
        {
            object entry = getValue(currencyIds, i);
            object splitEntry = ((string)entry).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
            object feeInfo = getValue(data, getValue(currencyIds, i));
            object currencyId = this.safeString(feeInfo, "asset");
            object currency = this.safeCurrency(currencyId);
            object code = this.safeString(currency, "code");
            if (isTrue(isTrue((isEqual(codes, null))) || isTrue((this.inArray(code, codes)))))
            {
                object depositWithdrawFee = this.safeValue(depositWithdrawFees, code);
                if (isTrue(isEqual(depositWithdrawFee, null)))
                {
                    ((IDictionary<string,object>)depositWithdrawFees)[(string)code] = this.depositWithdrawFee(new Dictionary<string, object>() {});
                }
                ((IDictionary<string,object>)getValue(getValue(depositWithdrawFees, code), "info"))[(string)entry] = feeInfo;
                object networkId = this.safeString(splitEntry, 1);
                object withdrawFee = this.safeValue(feeInfo, "withdraw_tx_fee");
                object withdrawResult = new Dictionary<string, object>() {
                    { "fee", withdrawFee },
                    { "percentage", ((bool) isTrue((!isEqual(withdrawFee, null)))) ? false : null },
                };
                object depositResult = new Dictionary<string, object>() {
                    { "fee", null },
                    { "percentage", null },
                };
                if (isTrue(!isEqual(networkId, null)))
                {
                    object networkCode = this.networkIdToCode(networkId);
                    ((IDictionary<string,object>)getValue(getValue(depositWithdrawFees, code), "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                        { "withdraw", withdrawResult },
                        { "deposit", depositResult },
                    };
                } else
                {
                    ((IDictionary<string,object>)getValue(depositWithdrawFees, code))["withdraw"] = withdrawResult;
                    ((IDictionary<string,object>)getValue(depositWithdrawFees, code))["deposit"] = depositResult;
                }
            }
        }
        object depositWithdrawCodes = new List<object>(((IDictionary<string,object>)depositWithdrawFees).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(depositWithdrawCodes)); postFixIncrement(ref i))
        {
            object code = getValue(depositWithdrawCodes, i);
            object currency = this.currency(code);
            ((IDictionary<string,object>)depositWithdrawFees)[(string)code] = this.assignDefaultDepositWithdrawFees(getValue(depositWithdrawFees, code), currency);
        }
        return depositWithdrawFees;
    }

    public override object handleMarginModeAndParams(object methodName, object parameters = null, object defaultValue = null)
    {
        /**
        * @ignore
        * @method
        * @description marginMode specified by params["marginMode"], this.options["marginMode"], this.options["defaultMarginMode"], params["margin"] = true or this.options["defaultType"] = 'margin'
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {Array} the marginMode in lowercase
        */
        parameters ??= new Dictionary<string, object>();
        object defaultType = this.safeString(this.options, "defaultType");
        object isMargin = this.safeBool(parameters, "margin", false);
        object marginMode = null;
        var marginModeparametersVariable = base.handleMarginModeAndParams(methodName, parameters, defaultValue);
        marginMode = ((IList<object>)marginModeparametersVariable)[0];
        parameters = ((IList<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, null)))
        {
            if (isTrue(isTrue((isEqual(defaultType, "margin"))) || isTrue((isEqual(isMargin, true)))))
            {
                marginMode = "isolated";
            }
        }
        return new List<object>() {marginMode, parameters};
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        path = this.implodeParams(path, parameters);
        object url = add(add(add(add(getValue(getValue(this.urls, "api"), api), "/"), this.version), "/"), path);
        object query = this.omit(parameters, this.extractParams(path));
        object nonce = ((object)this.nonce()).ToString();
        if (isTrue(isEqual(method, "POST")))
        {
            object parts = ((string)path).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
            object firstPart = this.safeString(parts, 0, "");
            object numParts = getArrayLength(parts);
            object lastPart = this.safeString(parts, subtract(numParts, 1), "");
            object lastWords = ((string)lastPart).Split(new [] {((string)"_")}, StringSplitOptions.None).ToList<object>();
            object numWords = getArrayLength(lastWords);
            object lastWord = this.safeString(lastWords, subtract(numWords, 1), "");
            if (isTrue(isTrue((isEqual(firstPart, "order"))) && isTrue((isTrue(isEqual(lastWord, "limit")) || isTrue(isEqual(lastWord, "market"))))))
            {
                // inject in implicit API calls
                // POST /order/limit - Place limit orders
                // POST /order/market - Place market orders
                // POST /order/stop/limit - Place stop limit orders
                // POST /order/stop/market - Place stop market orders
                // POST /perpetual/v1/order/put_limit - Place limit orders
                // POST /perpetual/v1/order/put_market - Place market orders
                // POST /perpetual/v1/order/put_stop_limit - Place stop limit orders
                // POST /perpetual/v1/order/put_stop_market - Place stop market orders
                object clientOrderId = this.safeString(parameters, "client_id");
                if (isTrue(isEqual(clientOrderId, null)))
                {
                    object defaultId = "x-167673045";
                    object brokerId = this.safeValue(this.options, "brokerId", defaultId);
                    ((IDictionary<string,object>)query)["client_id"] = add(add(brokerId, "_"), this.uuid16());
                }
            }
        }
        if (isTrue(isEqual(api, "perpetualPrivate")))
        {
            this.checkRequiredCredentials();
            query = this.extend(new Dictionary<string, object>() {
                { "access_id", this.apiKey },
                { "timestamp", nonce },
            }, query);
            query = this.keysort(query);
            object urlencoded = this.rawencode(query);
            object signature = this.hash(this.encode(add(add(urlencoded, "&secret_key="), this.secret)), sha256);
            headers = new Dictionary<string, object>() {
                { "Authorization", ((string)signature).ToLower() },
                { "AccessId", this.apiKey },
            };
            if (isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "PUT")))))
            {
                url = add(url, add("?", urlencoded));
            } else
            {
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/x-www-form-urlencoded";
                body = urlencoded;
            }
        } else if (isTrue(isTrue(isEqual(api, "public")) || isTrue(isEqual(api, "perpetualPublic"))))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else
        {
            this.checkRequiredCredentials();
            query = this.extend(new Dictionary<string, object>() {
                { "access_id", this.apiKey },
                { "tonce", nonce },
            }, query);
            query = this.keysort(query);
            object urlencoded = this.rawencode(query);
            object signature = this.hash(this.encode(add(add(urlencoded, "&secret_key="), this.secret)), md5);
            headers = new Dictionary<string, object>() {
                { "Authorization", ((string)signature).ToUpper() },
                { "Content-Type", "application/json" },
            };
            if (isTrue(isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE")))) || isTrue((isEqual(method, "PUT")))))
            {
                url = add(url, add("?", urlencoded));
            } else
            {
                body = this.json(query);
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        object code = this.safeString(response, "code");
        object data = this.safeValue(response, "data");
        object message = this.safeString(response, "message");
        if (isTrue(isTrue((!isEqual(code, "0"))) || isTrue((isTrue(isTrue(isTrue((!isEqual(message, "Success"))) && isTrue((!isEqual(message, "Succeeded")))) && isTrue((!isEqual(message, "Ok")))) && !isTrue(data)))))
        {
            object feedback = add(add(this.id, " "), message);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
